

# How to package a Python
<hr>

In this chapter we will develop an entire example Python package from beginning-to-end to demonstrate the key steps involved in developing a package. This chapter forms the foundation of this book, it contains everything you need to know to create a Python package. The intention is for readers to go through it once, and then use it as a quick-reference sheet to refer to when creating Python packages in the future. For those looking to learn even more, later chapters explore each of the individual steps in the packaging process in further detail.

The example package we are going to create in this chapter will help us calculate word counts from a plain-text file. We'll be calling it `pycounts` and it will be useful for parsing and understanding word usage in texts such as novels, research papers, news articles, log files, and more.

## Counting words in a text file

### Developing our code

Before even thinking about making a package, we'll first develop the code we want to package up. The `pycounts` package we are going to create will help us calculate word counts from a plain-text file. Python has a useful `Counter` object (which can be imported from the `collections` module) that can be used to calculate counts of a collection of elements (like a list of words) and store them in a dictionary.

We can demonstrate the functionality of `Counter` by first opening up a Python interpreter by typing `python` at the command line:

```{prompt} bash \$ auto
$ python
```

And importing `Counter` from the `collections` module:

```python
>>> from collections import Counter
```

We can then define a sample list of words and create a `Counter` object by passing that list of words as an input to `Counter()`:

```python
>>> words = ["a", "happy", "hello", "a", "world", "happy"]
>>> word_counts = Counter(words)
>>> word_counts
```

```console
Counter({'a': 2, 'happy': 2, 'hello': 1, 'world': 1})
```

<!-- #region -->
The `Counter` object automatically calculated the count of each unique word in our list and returned the result as a dictionary of `'word': count` pairs!

So, how can we use `Counter` to count the words in a given text file? Well, we could load the file, split it up into a list of words, and then create a `Counter` object from that list of words.

We first need a text file to help us build this workflow. "[The Zen of Python](https://www.python.org/dev/peps/pep-0020/)" is a list of 19 aphorisms about the Python programming language which can be viewed by executing `import this` in Python:

```python
>>> import this
```

```console
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
...
```

Let's export "The Zen of Python" as a text file called *`zen.txt`*. You can do this by manually copying the output of `import this` into a file called *`zen.txt`* using an editor of your choice, or you can do it from the command line by first exiting the Python interpreter:

```python
>>> exit()
```

Then running the following command:

```{prompt} bash \$ auto
$ python -c "import this" > zen.txt
```

>In the command above, the `-c` option allows you to pass a string for Python to execute, and the `>` directs the output of the command to a file (which in our case is called "zen.txt" and is located in the current directory).

Now that we have a text file to work with, we can go back to developing our word counting functionality. To open our *`zen.txt`* file in Python, we can use the `open()` function to open the file and then the `.read()` method to read its contents as a Python string. The code below, run in a Python interpreter, saves the contents of *`zen.txt`* as a string in the variable `text`:

```python
>>> with open("zen.txt") as file:
        text = file.read()
```

Let's see what `text` looks like:

```python
>>> text
```

```console
"The Zen of Python, by Tim Peters\n\nBeautiful is better
than ugly.\nExplicit is better than implicit.\nSimple is 
better than complex.\nComplex is better than complicated
..."
```

We can see that the `text` variable is a single string, with the `\n` symbols indicates a new-line in the string.

Before we split the above text into individual words for counting with `Counter`, we should lowercase all the letters and remove punctuation so that if the same word occurs multiple times with different capitalization or punctuation, it isn't treated as different words by `Counter`. For example we want "Better", "better", and "better!" to result in three counts of the word "better".

To lowercase all letters in a Python string, we can use the `.lower()` method:

```python
>>> text = text.lower()
```

To remove punctuation, we can iterate over a collection of punctuation marks and replace them with nothing using the `.replace()` method. Python conveniently provides a collection of punctuation marks in the `string` module:

```python
>>> from string import punctuation
>>> punctuation
```

```console
'!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~'
```

We can use a `for` loop to remove each punctuation mark from `text` by replacing it with an empty string (`""`):

```python
>>> for p in punctuation:
        text = text.replace(p, "")
```

With punctuation removed and the letters in `text` all lowercase, we can now split it up into individual words using the `.split()` method, which by default will split a string into a list of strings using spaces, newlines (`\n`) and tabs (`\t`):

```python
>>> words = text.split()
>>> words
```

```console
['the', 'zen', 'of', 'python', 'by', 'tim', 'peters', 
'beautiful', 'is', 'better', 'than', 'ugly', ...]
```

We've now managed to load, pre-process, and split our `*zen.txt*` file up into individual words and can now determine the word counts by creating a `Counter` object:

```python
>>> from collections import Counter
>>> word_counts = Counter(words)
>>> word_counts
```

```console
Counter({'is': 10, 'better': 8, 'than': 8, 'the': 6, 
'to': 5, 'of': 3, 'although': 3, 'never': 3, ... })
```
<!-- #endregion -->

### Turning our code into functions

<!-- #region -->
In **{numref}`03:Developing-our-code`** we developed a workflow for counting words in a text file. But it would be a pain to run all that code every time we want to count the words in a file! To make things more efficient, let’s turn the above code into three reusable functions called `load_text()`, `clean_text()` and `count_words()` by defining them in our Python interpreter:

>We've added a short documentation string (docstring) to each function here using triple quotes. We'll talk more about docstrings in **{numref}`03:Writing-docstrings`**.

```python
>>> def load_text(input_file):
        """Load text from a text file and return as a string."""
        with open(input_file, "r") as file:
            text = file.read()
        return text
```

```python
>>> def clean_text(text):
        """Lowercase and remove punctuation from a string."""
        text = text.lower()
        for p in punctuation:
            text = text.replace(p, "")
        return text
```

```python
>>> def count_words(input_file):
        """Count unique words in a string."""
        text = load_text(input_file)
        text = clean_text(text)
        words = text.split()
        return Counter(words)
```

We can now use our word-counting functionality as follows:

```python
>>> count_words("zen.txt")
```

```console
Counter({'is': 10, 'better': 8, 'than': 8, 'the': 6, 
'to': 5, 'of': 3, 'although': 3, 'never': 3, ... })
```

Unfortunately, if you quit from the Python interpreter, the functions we defined will be lost and you will have to define them again in new sessions.

The whole idea of a Python package is that we can store Python code, like our `load_text()`, `clean_text()` and `count_words()` functions, in a package that we, and others, can then install and `import` to use in any project without having to re-write it. In the remainder of this chapter, we'll work towards packaging up the code we've written into a Python package called `pycounts` so we can do exactly that.
<!-- #endregion -->

## Package structure

### A brief introduction

To develop our `pycounts` package we first need to create an appropriate directory structure. We talk about package structure in detail in **{numref}`04:Package-structure`**, but provide a practical summary here that contains everything you need to know to build your own package. 

Python packages are a collection of Python modules; files with a *.py* extension that contain the Python code you want to package up. A package comprises a specific directory structure of one or more Python modules, along with instructions on how to build and install the package on a computer. Below is an example package structure containing two modules:

```
example_pkg
├── src
│   └── example_pkg
│       ├── __init__.py
│       ├── module1.py
│       └── module2.py
├── README.md
└── pyproject.toml
```

The root directory is named after the package ("example_pkg" here). It contains a *`src/example_pkg`* subdirectory that shares the package's name and contains the Python source code (*.py* files) that make up the package. The *`__init__.py`* file tells Python to treat the directory as a package (we'll talk more about this file in **{numref}`04:The-__init__.py-file`**). *`README.md`* is a text file that provides high-level information about the package (what it does, how it can be used, its structure, etc.). The *`pyproject.toml`* file contains metadata about the project (who made it, how it is licensed, etc.) and instructions on how to build the package for installation and distribution, as we'll talk about in **{numref}`03:Installing-your-package`**.

The above structure is suitable for a simple package, or one intended solely for personal use. But packages typically include many more bells and whistles than this, such as detailed documentation, tests that can be run to validate the functionality of the package, and more. Below is a more typical example of a Python package structure:

```
example_pkg
├── CHANGELOG.md
├── CONDUCT.md
├── CONTRIBUTING.md
├── docs
│   └── ...
├── LICENSE
├── pyproject.toml
├── README.md
├── src
│   └── example_pkg
│       ├── __init__.py
│       ├── example_module1.py
│       └── example_module2.py
└── tests
    └── ...
```

The `pycounts` package we are going to create in this chapter will follow the latter package structure and we'll explore each element in that structure in the remainder of this chapter. Our reasoning for building a package with all the bells and whistles is to expose you to all the different elements of packaging; so that you understand them and can make informed choices about what content to include in your own packages in the future, depending on their intended use and audience.

### Creating a package structure

Regardless of your packaging expertise, it's efficient to use a pre-made template to set up the boilerplate directory structure of a package. We will use `cookiecutter` (a Python package we installed in **{numref}`02:Install-packaging-software`**) to create our package structure for us.

`cookiecutter` is a tool for populating a directory structure from a pre-made template. People have developed and open-sourced many `cookiecutter` templates for different projects; such as for creating Python packages, R packages, websites, and more. You can find these templates by, for example, searching an online hosting service like [GitHub](https://www.github.com). We have developed our own `py-pkgs-cookiecutter` Python package template to support this book, and which is hosted on [GitHub](https://github.com/py-pkgs/py-pkgs-cookiecutter).

To use this template to create a boilerplate directory structure, use the command line to navigate to the directory where you want to create your package, and then running the command below. Upon executing the command you will be prompted to provide information that will be used to create and customize your package file and directory structure. We provide an example of how to respond to these prompts and an explanation of what they mean in {numref}`prompt-table`.

```{prompt} bash \$ auto
$ cookiecutter https://github.com/py-pkgs/py-pkgs-cookiecutter.git
```

```console
author_name [Monty Python]: Tomas Beuzen
package_name [mypkg]: pycounts
package_short_description [A package for doing great things!]: Calculate word counts in a text file!
package_version [0.1.0]: 
python_version [3.9]: 
Select open_source_license:
1 - MIT
2 - Apache License 2.0
3 - GNU General Public License v3.0
4 - Creative Commons Attribution 4.0
5 - BSD 3-Clause
6 - Proprietary
7 - None
Choose from 1, 2, 3, 4, 5, 6 [1]: 
Select include_github_actions:
1 - no
2 - yes
Choose from 1, 2 [1]: 
```

```{table} A description of the py-pkgs-cookiecutter template prompts.
:name: prompt-table

|Prompt keyword|Description|
|:---  | :---  |
|`author_name`, `package_name`, `package_short_description`| These are self-explanatory. We provide guidance on choosing a good package name in **{numref}`04:Package-and-modules-names`**, but note that we will be publishing our `pycounts` package to Python's main package index [PyPI](https://pypi.org/). Package names on PyPI must be unique. **So if you plan to follow along with this tutorial you should choose a unique name for your package**. Something like `pycounts_[your intials]` might be appropriate, but you can check if a particular name is already taken by searching for it on [PyPI](https://pypi.org/).|
|`package_version`|The version of your package. Most Python packages use [semantic versioning](https://semver.org) for identifying their software. In semantic versioning, a version number consists of three integers A.B.C, where A is the "major" version, B is the "minor" version, and C is the "patch" version. The first version of a software usually starts at 0.1.0 and increments from there. We'll discuss versioning in **{numref}`Chapter %s<07:Releasing-and-versioning>`**.|
|`python_version`|The minimum version of Python you want to support.|
|`open_source_license`|The license to use that dictates how your package can be used by others. We discuss licenses in **{numref}`06:License`**. The [MIT license](https://choosealicense.com/licenses/mit/) we chose in our example response is a simple, permissive license commonly used for open source work. If your project will not be open source or you wish to retain exclusive copyright, you can choose not to include a license.|
|`include_github_actions`|An option to include continuous integration and continuous deployment files to help automate the building, testing and deployment of your Python package using the [GitHub Actions](https://github.com/features/actions) service. We'll explore these topics in more detail in **Chapter 8: [Continuous integration and deployment]**, so for now, we recommend responding `no`.|
```

After responding to the `py-pkgs-cookiecutter` prompts, we now have a new directory called `pycounts`, full of content suitable for building a fully-featured Python package! We'll explore each element of this directory structure as we develop our package throughout this chapter, but we've given a rough indication of what each file is related to below:

```
pycounts
├── .readthedocs.yml           ┐
├── CHANGELOG.md               │
├── CONDUCT.md                 │
├── CONTRIBUTING.md            │
├── docs                       │
│   ├── make.bat               │
│   ├── Makefile               │
│   ├── requirements.txt       │
│   ├── changelog.md           │
│   ├── conduct.md             │
│   ├── conf.py                │ Package documentation
│   ├── contributing.md        │
│   ├── index.md               │
│   └── usage.ipynb            │
├── LICENSE                    │
├── README.md                  ┘
├── pyproject.toml             ┐ 
├── src                        │
│   └── pycounts               │ Package source code, metadata,
│       ├── __init__.py        │ and build instructions 
│       └── pycounts.py        ┘
└── tests                      ┐
    └── test_pycounts.py       ┘ Package tests
```

## Put your package under version control

<!-- #region -->
Before continuing to develop our package it is generally good practice to put it under local and remote version control. This is not necessary for developing a package but is highly recommended so that you can better manage and track changes to your package over time. Version control is particularly useful and important if you plan on sharing and collaborating on your package with others. If you don't want to use version control, feel free to skip to **{numref}`03:Packaging-your-code`**. The tools we will be using for version control in this book are Git and GitHub (which we set up in **{numref}`02:Set-up-Git-and-GitHub`)**. 

>For this book, we assume readers have basic familiarity with Git and GitHub (or similar). To learn more about Git and GitHub, we recommend the following resources: [Happy Git and GitHub for the useR](https://happygitwithr.com) {cite:p}`bryan2021` and [Research Software Engineering with Python: Using Git at the Command Line](https://merely-useful.tech/py-rse/git-cmdline.html) {cite:p}`rsep2021b`

<!-- #endregion -->

### Set up local version control

To set up local version control, navigate to the root `pycounts` directory and initialize a Git repository:

```{prompt} bash \$ auto
$ cd pycounts
$ git init
```

```console
Initialized empty Git repository in /Users/tomasbeuzen/pycounts/.git/
```

Next, we need to tell Git which files to track (which will be all of them at this point) and then commit these changes locally:

```{prompt} bash \$ auto
$ git add .
$ git commit -m "initial package setup"
```

```console
[master (root-commit) 51795ad] initial package setup
 20 files changed, 502 insertions(+)
 create mode 100644 .gitignore
 create mode 100644 .readthedocs.yml
 create mode 100644 CHANGELOG.md
 ...
 create mode 100644 src/pycounts/__init__.py
 create mode 100644 src/pycounts/pycounts.py
 create mode 100644 tests/test_pycounts.py
```

### Set up remote version control

<!-- #region -->
Now that we have set up our local version control, we will create a repository on [GitHub](https://github.com/) and set that as the remote version control home for this project. First we need to create a new repository on [GitHub](https://www.github.com) as demonstrated in {numref}`03-set-up-github-1`:

```{r 03-set-up-github-1, fig.cap = "Creating a new repository in GitHub.", out.width = "100%", fig.retina = 2, fig.align = "center", echo = FALSE, message = FALSE, warning = FALSE}
knitr::include_graphics("../images/03-set-up-github-1.png")
```

To follow along with this tutorial, select the following options when setting up your GitHub repository, as shown in {numref}`03-set-up-github-2`: 

1. Give the GitHub repository the same name as your Python package and give it a short description;
2. You can choose to make your repository public or private - we'll be making ours public so we can share it with others; and,
3. Do not initialize the GitHub.com repository with any files (we've already created the files we need using our `py-pkgs-cookiecutter` template).

```{r 03-set-up-github-2, fig.cap = "Setting up a new repository in GitHub.", out.width = "100%", fig.retina = 2, fig.align = "center", echo = FALSE, message = FALSE, warning = FALSE}
knitr::include_graphics("../images/03-set-up-github-2.png")
```

Next, copy the remote link to your repository and then use the commands shown on GitHub, and outlined in {numref}`03-set-up-github-3`, to link your local repository with the remote repository, and push your project to GitHub:

```{r 03-set-up-github-3, fig.cap = "Instructions on how to link local and remote version control repositories.", out.width = "100%", fig.retina = 2, fig.align = "center", echo = FALSE, message = FALSE, warning = FALSE}
knitr::include_graphics("../images/03-set-up-github-3.png")
```

```{prompt} bash \$ auto
$ git remote add origin git@github.com:TomasBeuzen/pycounts.git
$ git branch -M main
$ git push -u origin main
```

```console
Enumerating objects: 26, done.
Counting objects: 100% (26/26), done.
Delta compression using up to 8 threads
Compressing objects: 100% (19/19), done.
Writing objects: 100% (26/26), 8.03 KiB | 4.01 MiB/s, done.
Total 26 (delta 0), reused 0 (delta 0)
To github.com:TomasBeuzen/pycounts.git
 * [new branch]      main -> main
Branch 'main' set up to track remote branch 'main' from 'origin'.
```

>The commands above should be specific to your GitHub username and the name of your Python package. The example above uses SSH authentication with GitHub which we recommend setting up. SSH is useful for connecting to GitHub without having to supply your username and password every time. If you're interested in setting up SSH, take a look at the GitHub [documentation](https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh). If you don't have SSH authentication set up, HTTPS authentication works as well and would require the use of the following url in place of the one shown above to set the remote: `https://github.com/TomasBeuzen/pycounts.git`. 

<!-- #endregion -->

## Packaging your code

We now have our package structure set up, and are ready to populate our package with the `load_text()`, `clean_text()` and `count_words()` functions we developed at the beginning of the chapter. Where should we put these functions? Let's review the structure of our package:

```
pycounts
├── .readthedocs.yml
├── CHANGELOG.md
├── CONDUCT.md
├── CONTRIBUTING.md
├── docs
│   └── ...
├── LICENSE
├── pyproject.toml
├── README.md
├── src
│   └── pycounts
│       ├── __init__.py
│       └── pycounts.py
└── tests
    └── ...
```

All the code that we would like the user to run as part of our package should live in modules in the `src/` directory. Our `py-pkgs-cookiecutter` template already created a Python module for us to put our code in called `src/pycounts/pycounts.py` (note that this module can be named anything, but it is common for a module to share the name of the package). We'll save our functions there.

Because our functions depends on `collections.Counter` and `string.punctuation`, we should also be sure to import them at the top of the file. Here's what *`src/pycounts/pycounts.py`* should now look like:

```python
from collections import Counter
from string import punctuation

def load_text(input_file):
    """Load text from a text file and return as a string."""
    with open(input_file, "r") as file:
        text = file.read()
    return text
    
def clean_text(text):
    """Lowercase and remove punctuation from a string."""
    text = text.lower()
    for p in punctuation:
        text = text.replace(p, "")
    return text
    
def count_words(input_file):
    """Count unique words in a string."""
    text = load_text(input_file)
    text = clean_text(text)
    words = text.split()
    return Counter(words)
```

## Test drive your package code

### Create a virtual environment

Before we install and test our package, it is highly recommended to set up a virtual environment. As discussed previously in **{numref}`02:Installing-Python`**, a virtual environment provides a safe and isolated space for us to install our package and any other packages it depends on. If you don't want to use a virtual environment, feel free to skip to **{numref}`03:Installing-your-package`**.

There are several options available when it comes to creating and managing virtual environments (e.g., `conda`, `virtualenv`, etc.). We will use `conda` (which we installed in **{numref}`02:Installing-Python`**) because it is a simple, commonly-used, and effective tool for managing virtual environments.

To use `conda` to create and activate a new virtual environment called `pycounts` that includes Python 3.9, run the following in your terminal:

```{prompt} bash \$ auto
$ conda create --name pycounts python=3.9 -y
```

>We are using Python 3.9 because that is the minimum version of Python we specified that our package will support in **{numref}`03:Creating-a-package-structure`**.

To use this new environment for developing and installing software, we should "activate" the environment:

```{prompt} bash \$ auto
$ conda activate pycounts
```

In most command lines, `conda` will add a prefix like `(pycounts)` to your command-line prompt to indicate which environment you are working in. Anytime you wish to work on your package, you should activate its virtual environment.  At this point, our `pycounts` environment should only have Python 3.9 and a small collection of its dependencies installed.

>You can view the packages installed in a `conda` environment using the command `conda list` and you can exit a `conda` virtual environment anytime using `conda deactivate`.


### Installing your package

We have our package structure set up and we've populated it with some Python code. Now, how do we install and use it? There are several tools available to develop installable Python packages; `poetry`, `flit`, `setuptools`, and more. We compare and contrast these tools in **{numref}`04:Packaging-tools`**. In this book we will be using `poetry` (which we installed in **{numref}`02:Install-packaging-software`**), because it is a modern packaging tool that provides simple and efficient commands to develop, install, and distribute Python packages.

`poetry` uses the *`pyproject.toml`* file to store information about a package and configure how it should be installed. The *`pyproject.toml`* that the `py-pkgs-cookiecutter` automatically created for our `pycounts` package looks like this:

```toml
[tool.poetry]
name = "pycounts"
version = "0.1.0"
description = "Calculate word counts in a text file."
authors = ["Tomas Beuzen"]
license = "MIT"
readme = "README.md"

[tool.poetry.dependencies]
python = "^3.9"

[tool.poetry.dev-dependencies]

[build-system]
requires = ["poetry-core>=1.0.0"]
build-backend = "poetry.core.masonry.api"
```

{numref}`toml-table` provides a brief description of each of the headings in that file (called "tables" in TOML file jargon).

```{table} A description of the tables in the pyproject.toml.
:name: toml-table

|TOML table|Description|
|:---  | :---  |
|`[tool.poetry]`|Contains metadata about a package. The `name`, `version`, `description`, and `authors` of the package must be defined, but there are also other optional metadata that can be defined as described in the `poetry` [documentation](https://python-poetry.org/docs/pyproject/#dependencies-and-dev-dependencies).|
|`[tool.poetry.dependencies]`|Identifies the dependencies of a package - that is, other software required to use your package. Currently our `pycounts` package only depends on Python 3.9 or higher, but we'll add some other dependencies to our package later in this chapter.|
|`[tool.poetry.dev-dependencies]`|Identifies development dependencies of our package. These are packages required for development purposes such as running tests or building documentation. We'll add development dependencies to our `pycounts` package later in this chapter.|
|`[build-system]`|Identifies the build tools required to build your package. We'll talk more about this in **{numref}`03:Building-and-distributing-your-package`**.|
```

<!-- #region -->
With our *`pyproject.toml`* file already set up for us by the `py-pkgs-cookiecutter` template, we can go right ahead and use `poetry` to install our package using the command `poetry install` from the root package directory:

```{prompt} bash \$ auto
$ poetry install
```

```console
Updating dependencies
Resolving dependencies... (0.1s)

Writing lock file

Installing the current project: pycounts (0.1.0)
```

```{tip language="tip"}
When installing your package for the first time, `poetry` also creates a *`poetry.lock`* file, which contains the exact versions of all the packages you've installed for your project. Subsequent runs of `poetry install` will install packages based on *`poetry.lock`*. This can be helpful for anyone developing your project (including you in the future) because it means they can use the exact same versions of the dependencies that you used when you created the project - even if those dependencies have since released new versions. We won't be focusing on *`poetry.lock`* in this book but it can be a helpful collaborative development tool which you can read more about in the `poetry` [documentation](https://python-poetry.org/docs/basic-usage/#installing-dependencies). 
```

With our package installed, we can now `import` and use it in a Python session. Before we do that, we need a text file to test our package on. Feel free to use any text file here, but for now, we'll create the same "Zen of Python" text file we used earlier in the chapter by running the following at the command line:

```{prompt} bash \$ auto
$ python -c "import this" > zen.txt
```

Now we can open an interactive Python session and `import` and use the `count_words()` function from our `pycounts` module with the following code:

```python
>>> from pycounts.pycounts import count_words
>>> count_words("zen.txt")
```

```console
Counter({'is': 10, 'better': 8, 'than': 8, 'the': 6, 
'to': 5, 'of': 3, 'although': 3, 'never': 3, ... })
```

Looks like everything is working! We now have created and installed a simple Python package! You can now use this Python package in any project you wish (if using virtual environments, you'll need to `poetry install` the package in them before it can be used).

It's important to note that `poetry install` installs packages in "editable mode", which essentially means that it installs a link to your package's code on your computer. This is common practice for developers because it means that any edits you now make to your package's source code are immediately available the next time you `import` it, without having to `poetry install` again. We'll talk about installing non-editable versions of your package in **{numref}`03:Building-and-distributing-your-package`**.

In the next section, we'll show how to add code to our package that relies on a dependency not in the standard Python library. But for those using version control, it's a good idea to commit the changes we've made to *`src/pycounts/pycounts.py`* to local and remote version control:

```{prompt} bash \$ auto
$ git add src/pycounts/pycounts.py
$ git commit -m "feat: add word counting functions"
$ git push
```

>In this book we use the [Angular commit message style](https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines). We'll talk about this style more in **{numref}`07:Automatic-version-bumping`**, but messages have the basic form "type: subject", where "type" indicates the kind of change being made and "subject" contains a description of the change. In this book, we'll use the follow "types" to identify our commits:
- "build": indicates a change to the build system or external dependencies.
- "docs": indicates a change to documentation.
- "feat": indicates a new feature being added to the code base.
- "fix": indicates a bug fix.
- "test": indicates changes to testing framework.

<!-- #endregion -->

## Adding code with dependencies to your package

Let's now add some new functionality to our package; a plotting function that will plot a bar chart of the top `n` words in a text file.

Imagine we've come up with the following `plot_words()` function that creates a bar chart of the top `n` words in a `Counter` object of words counts. The code itself is not overly important to our discussion, but we'll briefly explain it. The function uses the `.most_common()` method of the `Counter` object to find the top `n` word counts in the object and returns a list of `n` tuples of the format `(word, count)`. It then uses the Python short-hand `zip(*...)` to unpack that list of tuples into two individual lists, `word` and `count`. Finally, the `matplotlib` package is used to plot the result (`plt.bar(...)`), which looks like {numref}`03-matplotlib-figure`.

```python
import matplotlib.pyplot as plt

def plot_words(word_counts, n=10):
    """Plot a bar chart of word counts."""
    top_n_words = word_counts.most_common(n)
    word, count = zip(*top_n_words)
    fig = plt.bar(range(n), count)
    plt.xticks(range(n), labels=word, rotation=45)
    plt.xlabel("Word")
    plt.ylabel("Count")
    return fig
```

```{r 03-matplotlib-figure, fig.cap = "Example figure created from the `plot_words()` function.", out.width = "80%", fig.retina = 2, fig.align = "center", echo = FALSE, message = FALSE, warning = FALSE}
knitr::include_graphics("../images/03-matplotlib-figure.png")
```

Where should we put this function in our package? You could certainly add all your package code into a single module (e.g., *`src/pycounts/pycounts.py`*), but as you add functionality to your package that module will quickly become overcrowded and hard to manage. Instead, as you write more code, it's a good idea to organize it into multiple, logical modules. With that in mind, we'll create a new module called *`src/pycounts/plotting.py`* to house our plotting function `plot_words()`. Create that new module in an editor of your choice, or by running the following command from your root package directory:

```{prompt} bash \$ auto
$ touch src/pycounts/plotting.py
```

Your package structure should now look like this:

```
pycounts
├── .readthedocs.yml
├── CHANGELOG.md
├── CONDUCT.md
├── CONTRIBUTING.md
├── docs
│   └── ...
├── LICENSE
├── pyproject.toml
├── README.md
├── src
│   └── pycounts
│       ├── __init__.py
│       ├── plotting.py
│       └── pycounts.py
└── tests
    └── ...
```

Open *`src/pycounts/plotting.py`* and add the `plot_words()` code above (don't forget to add the `import matplotlib.pyplot as plt` at the top of the module).

After doing this, if we tried to `import` our new function in a Python interpreter we'd get an error:

```python
>>> from pycounts.plotting import plot_words
```

```console
ModuleNotFoundError: No module named 'matplotlib'
```

This is because `matplotlib` is not part of the standard Python library, we need to install it and add it as a dependency of our `pycounts` package. We can do this with `poetry` using the command `poetry add`. This command will install the specified dependency into the current environment and will update the `[tool.poetry.dependencies]` section of the *`pyproject.toml`* file:

```{prompt} bash \$ auto
$ poetry add matplotlib
``` 

```console
Using version ^3.4.3 for matplotlib

Updating dependencies
Resolving dependencies...

Writing lock file

Package operations: 8 installs, 0 updates, 0 removals

  • Installing six (1.16.0)
  • Installing cycler (0.10.0)
  • Installing kiwisolver (1.3.1)
  • Installing numpy (1.21.1)
  • Installing pillow (8.3.1)
  • Installing pyparsing (2.4.7)
  • Installing python-dateutil (2.8.2)
  • Installing matplotlib (3.4.3)
```

If you open *`pyproject.toml`* file, you should now see `matplotlib` listed as a dependency under the `[tool.poetry.dependencies]` section (which previously only contained Python 3.9 as a dependency, as we saw in **{numref}`03:Installing-your-package`**):

```toml
[tool.poetry.dependencies]
python = "^3.9"
matplotlib = "^3.4.3"
```

We can now use our package in a Python interpreter as follows (be sure that the *`zen.txt`* file is in the current directory):

```python
>>> from pycounts.pycounts import count_words
>>> from pycounts.plotting import plot_words
>>> counts = count_words("zen.txt")
>>> fig = plot_words(counts, 10)
```

`>If running the above Python code in an interactive IPython shell or Jupyter notebook, the plot will be displayed automatically. If you're running from the Python shell, you'll need to run the `matplotlib` command `plt.show()` to display the plot:
>
>python
>>> import matplotlib.pyplot as plt
>>> plt.show()
```
````

We've made some important changes to our package in this section by adding a new module and a dependency, so those using version control should commit these changes:

```{prompt} bash \$ auto
$ git add src/pycounts/plotting.py
$ git commit -m "feat: add plotting module"
$ git add pyproject.toml poetry.lock
$ git commit -m "build: add matplotlib as a dependency"
$ git push
```

## Testing your package

### Writing tests

At this point we have developed a package that can count words in a text file and plot the results. But how can we be certain that our package works correctly and produces reliable results?

One thing we can do is write tests for our package that check the package is working as expected. This is particularly important if you intend to share your package with others (you don't want to share code that doesn't work!). Even if you don't intend to share your package, writing tests can still be helpful to catch errors in your code, and to write new code without breaking any tried-and-tested existing functionality. If you don't want to write to tests for your package feel free to skip to **{numref}`03:Package-documentation`**.

Many of us already conduct informal tests of our code by running it a few times in a Python session to see if it's working as we expect, and if not, changing the code and repeating the process. This is called "manual testing" or "exploratory testing". However, when writing software, it's preferable to define your tests in a more formal and reproducible way.

Tests in Python are often written with the `assert` statement. It checks the truth of an expression; if the expression is true, Python does nothing and continues running, but if it's false, the code terminates and shows a user-defined error message. For example, consider running the follow code in a Python interpreter:

```python
ages = [32, 19, 9, 75]
for age in ages:
    assert age >= 18, "Person is younger than 18!"
    print("Age verified!")
```

```console
Age verified!
Age verified!
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
AssertionError: Person is younger than 18!
```

Note how the first two "ages" (32 and 19) are verified, with an "Age verified!" message printed to screen. But the third age of 9 fails the `assert`, so an error message is raised and the program terminates, such that the last age of 75 is not checked.

Using the `assert` statement, let's write a test for the `count_words()` function of our `pycounts` package. There are different kinds of tests used to test software (unit tests, integration tests, regression tests, etc.) and we discuss these in **Chapter 5: [Testing]**. For now, we'll write a unit test. Unit tests evaluate a single "unit" of software, such as a Python function, to check that it produces an expected result. They consist of:

1. Some data to test the code with (called a "*fixture*"). The fixture is typically a small or simple version of the data the function will typically process;
2. The *actual* result that the code produces given the fixture; and,
3. The *expected* result of the test, which is compared to the *actual* result, typically using an `assert` statement.

So in our case, we want to `assert` that the `count_words()` function produces an expected result given a particular input. Consider the following quote from Albert Einstein:

>*"Insanity is doing the same thing over and over and expecting different results."*

We can manually count the words in that quote to get the following *expected* result (ignoring capitalization and punctuation):

```python
einstein_counts = {'insanity': 1, 'is': 1, 'doing': 1, 
                   'the': 1, 'same': 1, 'thing': 1, 
                   'over': 2, 'and': 2, 'expecting': 1,
                   'different': 1, 'results': 1}
```

A unit test for `count_words()` would therefore check that the *actual* result it produces given the raw quote as input, is the same as the *expected* result above. To write this test, let's first create a text file containing the Einstein quote to use in our unit test. We'll add it to the *`tests/`* directory of our package as a file called *`einstein.txt`* - you can make the file manually and copy the quote above, or you can create it from a Python session started in the root package directory using the following code:

```python
>>> quote = "Insanity is doing the same thing over and over and expecting different results."
>>> with open("tests/einstein.txt", "w") as file:
        file.write(quote)
```

Now, a unit test for our `count_words()` function would look as below:

```python
>>> from pycounts.pycounts import count_words
>>> from collections import Counter
>>> expected = Counter({'over': 2, 'and': 2, 'insanity': 1,
                        'is': 1, 'doing': 1, 'the': 1, 
                        'same': 1, 'thing': 1, 'expecting': 1,
                        'different': 1, 'results': 1})
>>> actual = count_words("tests/einstein.txt")
>>> assert actual == expected, "Einstein quote words counted incorrectly!"
```

If the above code runs without error, our `count_words()` function is working, at least to our test specifications. In the next section, we'll discuss how we can make this testing process more efficient.

### Running tests

<!-- #region -->
It would be tedious and inefficient to manually write and execute unit tests for your package's code in a Python interpreter like we did above. Instead, it's common to use a testing framework to automatically run our tests for us. `pytest` is one of the most commonly used testing frameworks for Python packages. To use `pytest`:

1. Tests are defined as functions prefixed with `test_` and contain one or more statements that `assert` code produces an expected result;
2. Tests are put in files of the form *`test_*.py`* or *`*_test.py`*, and are usually placed in a directory called *`tests/`* in a package's root; and,
3. Tests can be executed using the command `pytest` at the command line and pointing it to the directory your tests live in (i.e., `pytest tests/`). `pytest` will find all files of the form *`test_*.py`* or *`*_test.py`* in that directory and its sub-directories, and execute any functions with names prefixed with `test_`.

The `py-pkgs-cookiecutter` already created a *`tests/`* directory and a module called *`test_pycounts.py`* for us to put our tests in:

```
example_pkg
├── CHANGELOG.md
├── CONDUCT.md
├── CONTRIBUTING.md
├── docs
│   └── ...
├── LICENSE
├── poetry.lock
├── pyproject.toml
├── README.md
├── src
│   └── ...
└── tests
    ├── einstein.txt
    └── test_pycounts.py
```

>We created the file *`tests/einstein.txt`* ourselves in **{numref}`03:Writing-tests`**, it was not created by the `py-pkgs-cookiecutter`.

As mentioned above, `pytest` tests are written as functions prefixed with `test_` and which contains one or more `assert` statements that verifies some code functionality. Based on this format, let's add the unit test we created in **{numref}`03:Writing-tests`** as a test function to *`tests/test_pycounts.py`* using the below Python code:

```python
from pycounts.pycounts import count_words
from collections import Counter

def test_count_words():
    """Test word counting from a file."""
    expected = Counter({'over': 2, 'and': 2, 'insanity': 1, 'is': 1,
                        'doing': 1, 'the': 1, 'same': 1, 'thing': 1,
                        'expecting': 1, 'different': 1, 'results': 1})
    actual = count_words("tests/einstein.txt")
    assert actual == expected, "Einstein quote words counted incorrectly!"
```

Before we can use `pytest` to run our test for us we need to add it as a development dependency of our package using the command `poetry add --dev`. A development dependency is a package that is not required by a user to use your package, but is required for development purposes (like testing):

```{prompt} bash \$ auto
$ poetry add --dev pytest
```

If you look in the *`pyproject.toml`* file you will see that `pytest` gets added under the `[tool.poetry.dev-dependencies]` section (which was previously empty, as we saw in **{numref}`03:Installing-your-package`**):

```toml
[tool.poetry.dev-dependencies]
pytest = "^6.2.4"
```

To use `pytest` to run our test we can use the following command from our root package directory:

```{prompt} bash \$ auto
$ pytest tests/
```

```console
============================= test session starts ==============================
platform darwin -- Python 3.9.6, pytest-6.2.4, py-1.10.0, pluggy-0.13.1
rootdir: /Users/tomasbeuzen/pycounts
collected 1 item                                                                                                                                   

tests/test_pycounts.py .                                                  [100%]

============================== 1 passed in 0.01s ===============================
```

We get no error returned to us, indicating that our test passed! This suggests that the code we wrote is correct (at least to our test specifications)!

At this point, we could add more tests for our package by writing more `test_*` functions. But we'll do this in **Chapter 5: [Testing]**. Typically you want to write tests that cover all the core functionality of your package - we'll show how you can determine how much of your code your tests covers in the next section. For those using version control, commit your tests to local and remote version control:

```{prompt} bash \$ auto
$ git add pyproject.toml poetry.lock
$ git commit -m "build: add pytest as a dev dependency"
$ git add tests/*
$ git commit -m "test: add unit test for count_words"
$ git push
```
<!-- #endregion -->

### Test coverage

A good test suite will contain tests that cover the main functionality of your code, that is, your tests should run most or all of your code at least once. There are certainly exceptions to this, but the general idea is to have your tests cover the core functionality of your package. We refer to this as "coverage" and there is a useful extension to `pytest` called `pytest-cov` which we can use to automatically determine how much coverage our tests have.

Let's use `poetry` to add `pytest-cov` as a development dependency of our `pycounts` package now:

```{prompt} bash \$ auto
$ poetry add --dev pytest-cov
```

We can determine the coverage of our tests by running the following command which tells `pytest-cov` to determine the coverage our tests have of the `pycounts` package:

```{prompt} bash \$ auto
$ pytest tests/ --cov=pycounts
```

```console
============================= test session starts ==============================
platform darwin -- Python 3.9.6, pytest-6.2.4, py-1.10.0, pluggy-0.13.1
rootdir: /Users/tomasbeuzen/pycounts
plugins: cov-2.12.1
collected 1 item                                                                                                                                   

tests/test_pycounts.py .                                                  [100%]

---------- coverage: platform darwin, python 3.9.6-final-0 -----------
Name                       Stmts   Miss  Cover
----------------------------------------------
src/pycounts/__init__.py       2      0   100%
src/pycounts/plotting.py       9      9     0%
src/pycounts/pycounts.py      16      0   100%
----------------------------------------------
TOTAL                         27      9    67%

============================== 1 passed in 0.01s ===============================
```

In the output above, `Stmts` is how many lines are in a module, `Miss` is how many lines were not executed by your tests, and `Cover` is the percentage of lines executed by your tests. From the above output, we can see that our tests currently don't cover any of the lines in the `pycounts.plotting` module. We'll write more tests for our package, and discuss more advanced methods of testing and calculating code coverage in **Chapter 5: [Testing]**.

## Package documentation

Documentation describing what your package does and how to use it is invaluable for the users of your package (including yourself). The amount of documentation needed to support your package varies depending on its complexity and the intended audience. All packages should at least have:
- A README: a text file containing high-level information about the package, e.g., what it does, how to install it, and how to use it.
- docstrings: a docstring is a string at the start of a module, class, method or function that describes what the code does and how to use it.

The above documentation might suffice for a simple, personal package. But more complex packages and/or ones that will be shared and collaborated on with a larger audience will typically contain additional documents such as:
- A license: explains who owns the copyright to your package source and how it can be used and shared.
- Contributing guidelines: explains how to contribute to the project.
- A code of conduct: defines standards for how to engage with and contribute to the project.
- A Changelog: a chronologically ordered list of notable changes to your package over time, usually organized by version.
- Examples of usage: step-by-step examples showing how the package works in more detail.
- An application programming interface (API) reference: a list of the user-facing functionality of your package (i.e., functions, classes, etc.) along with a short description of what they do and how to use them.

We'll discuss these documents, and more, in detail in **Chapter 6: [Documentation]**. But regardless of how much documentation you intend to include in your package, it's common to develop it from a mix of manually written and automatically generated content using the documentation generator tool `sphinx`.

In this section, we will develop the documentation for our `pycounts` package. As we will be making `pycounts` open source and sharing it publicly, it will include all of the documentation listed above. We'll show how to compile this documentation and generate content automatically with `sphinx`, and how to host your documentation online using the free service [Read the Docs](https://readthedocs.org/).

### Writing documentation

Python package documentation is typically written in a plain-text markup format such as [Markdown](https://en.wikipedia.org/wiki/Markdown) (*.md*) or [reStructuredText](https://www.sphinx-doc.org/en/master/usage/restructuredtext/index.html) (*.rst*). We'll be using Markdown in this book because it is widely used, and we feel it has a less verbose and more intuitive syntax than reStructuredText (check out the [Markdown Guide](https://www.markdownguide.org) to learn more about Markdown syntax). For now, consider the layout of our `pycounts` package:

```
pycounts
├── .readthedocs.yml
├── CHANGELOG.md
├── CONDUCT.md
├── CONTRIBUTING.md
├── docs
│   └── ...
├── LICENSE
├── README.md
├── poetry.lock
├── pyproject.toml
├── src
│   └── ...
└── tests
    └── ...
```

The reality is that most developers create packages from templates and rarely have to write all of this documentation from scratch! The `py-pkgs-cookiecutter` template we used to create our package structure created and populated a *`CHANGELOG.md`*, *`CONDUCT.md`*, *`CONTRIBUTING.md`*, and *`LICENSE`* file for us. These files are usually found in the root directory of the package because they contain important information for those interested in using and/or contributing to your package. A basic *`README.md`* was also created for us but it contains a "Usage" section which is currently empty. Now that we've developed the basic functionality of `pycounts`, we can fill that section with Markdown text as follows:

````
# pycounts

Calculate word counts in a text file!

## Installation

```bash
$ pip install pycounts
```

## Usage

`pycounts` can be used to count words in a text file and plot the results as follows:

```python
from pycounts.pycounts import count_words
from pycounts.plotting import plot_words
import matplotlib.pyplot as plt

file_path = "test.txt"  # path to your file
counts = count_words(file_path)
fig = plot_words(counts, n=10)
plt.show()
```

## Contributing

Interested in contributing? Check out the contributing guidelines. Please note that this project is released with a Code of Conduct. By contributing to this project, you agree to abide by its terms.

## License

`pycounts` was created by Tomas Beuzen. It is licensed under the terms of the MIT license.

## Credits

`pycounts` was created with [`cookiecutter`](https://cookiecutter.readthedocs.io/en/latest/) and the `py-pkgs-cookiecutter` [template](https://github.com/py-pkgs/py-pkgs-cookiecutter).
````

>In the Markdown text above, the following syntax is used:
- Headers are denoted with number signs (\#). The number of number signs corresponds to the heading level.
- Code blocks are bounded by three back-ticks (\`\`\`). A programming language can succeed the opening bounds to specify how the code syntax should be highlighted.
- Links are defined using brackets \[\] to enclose the link text, followed by the URL in parentheses ().

So, we now have a *`CHANGELOG.md`*, *`CONDUCT.md`*, *`CONTRIBUTING.md`*, *`LICENSE`*, and *`README.md`*. In the next section, we'll explain how to document your package's Python code using docstrings.

### Writing docstrings

A docstring is a string, surrounded by triple-quotes, at the start of a module, class, or function in Python (preceding any code) that provides documentation on what the object does and how to use it. Docstrings automatically become the object's documentation, accessible to users via the `help()` function. Docstrings are a user's first port-of-call when they are trying to use your package, they really are a necessity when creating packages, even for yourself.

General docstring convention in Python is described in [Python Enhancement Proposal (PEP) 257 - Docstring Conventions](https://www.python.org/dev/peps/pep-0257/), but there is flexibility in how you write your docstrings. A minimal docstring contains a single line describing what the object does, and that might be sufficient for a simple function or for when your code is in the early stages of development. However, for code you intend to share with others (including your future self) a more comprehensive docstring should be written. A typical docstring will include:

1. A one-line summary that does not use variable names or the function name;
2. An extended description;
3. Parameter types and descriptions;
4. Returned value types and descriptions;
5. Example usage; and,
6. Potentially more.

There are different "docstring styles" used in Python to organize this information, such as [numpydoc style](https://numpydoc.readthedocs.io/en/latest/format.html#docstring-standard), [Google style](https://github.com/google/styleguide/blob/gh-pages/pyguide.md#38-comments-and-docstrings), and [sphinx style](https://sphinx-rtd-tutorial.readthedocs.io/en/latest/docstrings.html#the-sphinx-docstring-format). We'll be using the numpydoc style for our `pycounts` package because it is readable, commonly-used, and supported by `sphinx`. In the numpydoc style:
- Section headers are denoted as text underlined with dashes;
- Input arguments are denoted as:
    ```
    name : type
        Description of parameter `name`.
    ```
- Output values use the same syntax above, but specifying the `name` is optional.

We show a numpydoc style docstring for our `count_words()` function below (numbers in the docstring below identify items in the numbered list above, but they should not be included in your docstring):

```python
def count_words(input_file):
    """Count words in a text file. (1)

    Words are made lowercase and punctuation is removed 
    before counting. (2)

    Parameters (3)
    ----------
    input_file : str
        Path to text file.

    Returns (4)
    -------
    collections.Counter
        dict-like object where keys are words and values are their counts.

    Examples (5)
    --------
    >>> count_words("text.txt")
    """
    text = load_text(input_file)
    text = clean_text(text)
    words = text.split()
    return Counter(words)
```

You can add information to your docstrings at your discretion - you won't always need all the sections above, and in some case you may want to include additional sections from the numpydoc style [documentation](https://numpydoc.readthedocs.io/en/latest/format.html#docstring-standard). We've documented the remaining functions from our `pycounts` package as below. If you're following along with this tutorial, copy these docstrings into the functions in your *.py* files:

```python
def load_text(input_file):
    """Load text from a text file and return as a string.

    Parameters
    ----------
    input_file : str
        Path to text file.

    Returns
    -------
    str
        Text file contents.

    Examples
    --------
    >>> load_text("text.txt")
    """
    with open(input_file, "r") as file:
        text = file.read()
    return text

def clean_text(text):
    """Lowercase and remove punctuation from a string.

    Parameters
    ----------
    text : str
        Text to clean.

    Returns
    -------
    str
        Cleaned text.

    Examples
    --------
    >>> clean_text("Early optimization is the root of all evil!")
    'early optimization is the root of all evil'
    """
    text = text.lower()
    for p in punctuation:
        text = text.replace(p, "")
    return text

def plot_words(word_counts, n=10):
    """Plot a bar chart of word counts.

    Words are made lowercase and punctuation is removed 
    before counting.

    Parameters
    ----------
    word_counts : collections.Counter
        Counter object of word counts.
    n : int, optional
        Plot the top n words. By default, 10.

    Returns
    -------
    matplotlib.
        Bar chart of word counts.

    Examples
    --------
    >>> from pycounts.pycounts import count_words
    >>> from pycounts.plotting import plot_words
    >>> counts = count_words("text.txt")
    >>> plot_words(counts)
    """
    top_n_words = word_counts.most_common(n)
    word, count = zip(*top_n_words)
    fig = plt.bar(range(n), count)
    plt.xticks(range(n), labels=word, rotation=45)
    plt.xlabel("Word")
    plt.ylabel("Count")
    return fig
```

These docstrings can be accessed by users of our package by using the `help()` function in a Python interpreter:

```python
>>> from pycounts.pycounts import count_words
>>> help(count_words)
```

```console
Help on function count_words in module pycounts.pycounts:

count_words(input_file)
    Count words in a text file.
    
    Words are made lowercase and punctuation is removed 
    before counting.

    Parameters
    ----------
    input_file : str
        Path to text file.

    ...
```

However, for the users of our package it would be helpful to compile all of our functions and docstrings into a easy-to-navigate document, so they can access this information without having to `import` or search through our source code. Such a document is referred to as an application programming interface (API) reference. We could create one by manually copying and pasting all of our function names and docstrings into a plain-text file, but that would be inefficient. Instead, we'll show how to use `sphinx` in **{numref}`03:Generating-documentation`** to automatically parse our source code, extract our functions and docstrings, and create an API reference for us.

### Creating usage examples

<!-- #region -->
Creating examples of how to use your package can be invaluable to new and existing users alike. Unlike the brief and basic "Usage" heading we wrote in our README in **{numref}`03:Writing-documentation`**, these examples are more like tutorials, including a mix of text and code that demonstrates the functionality and common workflows of your package step-by-step.

You could write examples from scratch using a plain-text format like Markdown but this can be inefficient and prone to errors. If you change the way a function works, or what it outputs, you would have to re-write your example. Instead, in this section we'll show how to use Jupyter notebooks as a more efficient, interactive, and reproducible way to create usage examples for your users. If you don't want to create usage example for your package, or aren't interested in learning how to use Jupyter notebooks to do so, you can skip to **{numref}`03:Generating-documentation`**.

Jupyter notebook (*.ipynb* file). Jupyter notebooks are interactive documents that can contain code, equations, text, and visualizations. They are effective for demonstrating examples because they directly import and use code from your package; this ensures you don't make mistakes when writing out your example, and allows users to download, execute, and interact with the notebooks themselves (as opposed to just reading text). To create a usage example for our `pycounts` package using a Jupyter notebook, we first need to add `jupyter` as a development dependency:

```{prompt} bash \$ auto
$ poetry add --dev jupyter
```

Our `py-pkgs-cookiecutter` template already created a notebook for us at *`docs/example.ipynb`*. To edit that document, we first open the Jupyter Notebook application using the following command:

```{prompt} bash \$ auto
$ jupyter notebook
```

>If you're developing your Python package in an IDE that supports notebooks, such as VS Code or JupyterLab, feel free to edit *`pycounts/docs/example.ipynb`* there.

In the interface, navigate to and open *`docs/example.ipynb`*. As explained in the Jupyter Notebook [documentation](https://jupyter-notebook.readthedocs.io/en/stable/), notebooks are comprised of "cells" which can contain Python code or Markdown text. Our notebook currently looks like {numref}`03-jupyter-example-1`.

```{r 03-jupyter-example-1, fig.cap = "A simple Jupyter notebook using code from `pycounts`.", out.width = "100%", fig.retina = 2, fig.align = "center", echo = FALSE, message = FALSE, warning = FALSE}
knitr::include_graphics("../images/03-jupyter-example-1.png")
```

Let's update that example with the collection of Markdown and code cells shown in {numref}`03-jupyter-example-2`.

```{r 03-jupyter-example-2, fig.cap = "Jupyter notebook demonstrating an example workflow using the `pycounts` package.", out.width = "100%", fig.retina = 2, fig.align = "center", echo = FALSE, message = FALSE, warning = FALSE}
knitr::include_graphics("../images/03-jupyter-example-2.png")
```

Our Jupyter notebook now contains an interactive tutorial demonstrating the basic usage of our package. What's important to note is that the outputs are generated using the actual code from our package itself, they have not been written manually. This approach ensures that if we change any code, those changes would be automatically reflected in our examples.

While our users could download our example notebook so that they can interact and execute it themselves, in the next section, we'll show how to use `sphinx` to automatically execute notebooks and include their content (including the outputs of code cells) into a compiled collection of all our package's documentation that users can easily read and navigate through without having to start the Jupyter application!
<!-- #endregion -->

### Building documentation

<!-- #region -->
We've now written all the individual pieces of documentation needed to support our `pycounts` package. But all this documentation is not overly helpful in its current state because it's spread over the directory structure of our package making it inefficient to search through. 

This is where the documentation generator `sphinx` comes in. `sphinx` can be used to compile a collection of plain-text source files into user-friendly output formats such as HTML or PDF for sharing and/or hosting on the web. It also has a rich ecosystem of extensions that can be used to help automatically generate content - we'll be using some of these extensions in this section to help create an API reference sheet and to execute and render our Jupyter notebook example into our documentation.

To first give you an idea of what we're going to build, {numref}`03-documentation-1` shows the homepage of our package's documentation compiled by `sphinx` into HTML.

```{r 03-documentation-1, fig.cap = "The documentation homepage generated by `sphinx`.", out.width = "100%", fig.retina = 2, fig.align = "center", echo = FALSE, message = FALSE, warning = FALSE}
knitr::include_graphics("../images/03-documentation-1.png")
```

The source and configuration files to build documentation like this using `sphinx` typically live in a *`docs/`* folder in the root of your package. The `py-pkgs-cookiecutter` automatically created this for us:

```
pycounts
├── .readthedocs.yml
├── CHANGELOG.md
├── CONDUCT.md
├── CONTRIBUTING.md
├── docs
│   ├── changelog.md
│   ├── conduct.md
│   ├── conf.py
│   ├── contributing.md
│   ├── example.ipynb
│   ├── index.md
│   ├── make.bat
│   ├── Makefile
│   └── requirements.txt
├── LICENSE
├── poetry.lock
├── pyproject.toml
├── README.md
├── src
│   └── ...
└── tests
    └── ...
```

The *`docs/`* directory includes:

- *`Makefile`*/*`make.bat`*: files that contain commands needed to build our documentation with `sphinx` and do not need to be modified. [Make](https://www.gnu.org/software/make/) is a tool used to run commands to efficiently read, process, and write files. A Makefile defines the tasks for Make to execute. If you're interested in learning more about Make, we recommend the excellent tutorial [Learn Makefiles](https://makefiletutorial.com). But for building documentation with `sphinx`, all you need to know is that having these Makefiles allows us to build documentation with the simple command `make html` and clean documentation (i.e., remove it so we can make a fresh copy) with the command `make clean`.
- *`requirements.txt`*: contains a list of documentation-specific dependencies required to host our docs on [Read the Docs](https://readthedocs.org/), which we'll discuss in **{numref}`06:Hosting-documentation-online`**;
- *`conf.py`* is a configuration script controlling how `sphinx` builds your documentation. You can read more about *`conf.py`* in the `sphinx` [documentation](https://www.sphinx-doc.org/en/master/usage/configuration.html) and we'll touch on it again shortly, but for now, it has been pre-populated by the `py-pkgs-cookiecutter` template and does not need to be modified;
- The remaining files in the `docs` directory form the content of our generated documentation, as we'll discuss in the remainder of this section.

The *`index.md`* file forms the landing page of our documentation (the one we saw earlier in {numref}`03-documentation-1`). Think of it as the homepage of a website. If you open it in an editor of your choice, you'll see the following:

````
```{include} ../README.md
```

```{toctree}
:maxdepth: 1
:hidden:

example.ipynb
changelog.md
contributing.md
conduct.md
autoapi/index
```
````

The syntax we're using in this file is known as [Markedly Structured Text (MyST)](https://myst-parser.readthedocs.io/en/latest/syntax/syntax.html). MyST is based on Markdown but with additional syntax options compatible for use with `sphinx`. The `{include}` syntax specifies that we want this page to include the content of the *`README.md`* in our package's root directory (think of it as a copy-paste operation).

The `{toctree}` syntax defines what documents will be listed in the table of contents (ToC) on the left-hand side of {numref}`03-documentation-1`. The argument `:maxdepth: 1` indicates how many heading levels the ToC should include, and `:hidden:` specifies that the ToC should only appear in the side bar and not in the welcome page itself. The ToC then lists the documents we want to include in our rendered documentation.

"example.ipynb" is the notebook we wrote in section **{numref}`03:Creating-usage-examples`**. `sphinx` doesn't support relative links in a ToC, so to include the documents *`CHANGELOG.md`*, *`CONTRIBUTING.md`*, *`CONDUCT.md`* in our root, we create "stub files" *`changelog.md`*, *`contributing.md`*, and *`conduct.md`* which contain links to these documents with the `{include}` syntax from earlier (which does support relative links). For example, *`changelog.md`* contains the following text:

````
```{include} ../CHANGELOG.md
```
````

The final document in the ToC, "autoapi/index" is an API reference sheet that will be generated automatically for us, using our package structure and docstrings, when we build our documentation.

Before we can go ahead and build our documentation, it relies on a few extensions that need to be installed and configured:

- [myst-nb](https://myst-nb.readthedocs.io/en/latest/): extension that will enable `sphinx` to parse our Markdown, MyST, and notebook files (`sphinx` only supports reStructuredTex, *.rst* files, by default);
- [sphinx-rtd-theme](https://sphinx-rtd-theme.readthedocs.io/en/stable/): a custom theme for styling the way our documentation will look;
- [sphinx-autoapi](https://sphinx-autoapi.readthedocs.io/en/latest/): extension that will parse our source code to create an API reference sheet;
- [sphinx.ext.napoleon](https://sphinxcontrib-napoleon.readthedocs.io/en/latest/): extension that enables `sphinx` to parse both numpydoc-style docstrings; and,
- [sphinx.ext.viewcode](https://www.sphinx-doc.org/en/master/usage/extensions/viewcode.html): extension that adds a helpful link to the source code of each object in the API reference sheet.

All these extensions are not necessary to create documentation with `sphinx`, but they are all commonly used in Python packaging documentation and significantly improve the look and user-experience of the generated documentation. Extensions without the `sphinx.ext` prefix need to be installed. We can install them as development dependencies in a `poetry`-managed project with the following command:

```{prompt} bash \$ auto
$ poetry add --dev myst-nb sphinx-autoapi sphinx-rtd-theme
```

Once installed, any extensions you want to use need to be added to a list called `extensions` in the *`conf.py`* configuration file and configured. Configuration options for each extension (if they exist) can be viewed in their respective documentation, but the `py-pkgs-cookeicutter` has already taken care of everything for us, by defining the following variables within *`conf.py`*:

```python
extensions = [
    "myst_nb",
    "autoapi.extension",
    "sphinx.ext.napoleon",
    "sphinx.ext.viewcode",
    "sphinx_copybutton",
]
autoapi_dirs = ["../src"]
html_theme = "sphinx_rtd_theme"
```

With our documentation structure set up, and our extensions configured, we can now build our documentation with `sphinx` using the following command from our root package directory:

```{prompt} bash \$ auto
$ make html --directory=docs/
```

```console
Running Sphinx
making output directory... done
...
build succeeded.
The HTML pages are in _build/html.
```

If we look inside our *`docs/`* directory we see a new directory *`_build/html`* which contains our rendered HTML files. If you open *`_build/html/index.html`* you should see the page shown in {numref}`03-documentation-1`.

The `sphinx-autoapi` extension extracted the docstrings within each module and rendered them into our documentation. You can find the generated API reference sheet by clicking "API Reference" in the table of contents. For example, {numref}`03-documentation-2` shows the functions and docstrings in the `pycounts.plotting` module. The `sphinx.ext.napoleon` enabled `sphinx` to parse our [numpydoc style](https://numpydoc.readthedocs.io/en/latest/format.html#docstring-standard) docstrings and the `sphinx.ext.viewcode` extension added the "\[source\]" link next to each function in our API reference sheet which links readers directly to the source code of the function (if they want to view it).

```{r 03-documentation-2, fig.cap = "Documentation for the pycounts plotting module.", out.width = "100%", fig.retina = 2, fig.align = "center", echo = FALSE, message = FALSE, warning = FALSE}
knitr::include_graphics("../images/03-documentation-2.png")
```

Finally, if we navigate to the "Example usage" page, {numref}`03-documentation-3` shows the Jupyter notebook we wrote in **{numref}`03:Creating-usage-examples`** rendered into our documentation, including the Markdown text, code input, and executed output. This was made possible using the `myst-nb` extension.

```{r 03-documentation-3, fig.cap = "Jupyter notebook example rendered into `pycounts`'s documentation.", out.width = "100%", fig.retina = 2, fig.align = "center", echo = FALSE, message = FALSE, warning = FALSE}
knitr::include_graphics("../images/03-documentation-3.png")
```

Ultimately, you can easily and efficiently make beautiful and many-featured documentation with `sphinx` and its ecosystem of extensions. You can now use this documentation yourself or potentially share it with others, but it really shines when you host it on the web using a free service like [Read the Docs](https://readthedocs.org/), as we'll do in the next section. For those using version control, now is a good time to commit our work on our package's documentation:

```{prompt} bash \$ auto
$ git add README docs/example.ipynb
$ git commit -m "docs: updated readme and example"
$ git add src/pycounts/pycounts.py src/pycounts/plotting.py
$ git commit -m "docs: created docstrings for package functions"
$ git add pyproject.toml poetry.lock
$ git commit -m "build: added dev dependencies for docs"
$ git push
```
<!-- #endregion -->

### Hosting documentation online

<!-- #region -->
If you intend to share your package with others, it will be useful to make your documentation accessible online. It's common to host Python package documentation on the free online hosting service [Read the Docs](https://readthedocs.org/), which can automate the building, deployment, and hosting of your documentation directly from an online repository. 

Read the Docs works by connecting to an online repository hosting your package documentation, such as a GitHub repository. When you push changes to your repository, Read the Docs automatically builds a fresh copy of your documentation (i.e., runs `make html`) and hosts it at the URL <https://pkgname.readthedocs.io/> (you can also configure Read the Docs to use a custom domain name). This means that any changes you make to your documentation source files are immediately deployed to your users. If you need your documentation to be private (e.g., only available to employees of a company), Read the Docs offers a paid "Business plan" with this functionality.

The [Read the Docs](https://readthedocs.org) documentation will provide the most up-to-date steps required to host your documentation online. For our `pycounts` package, this involved the following steps:

1. Visit <https://readthedocs.org/> and click on "Sign up";
2. Select "Sign up with GitHub";
3. Click "Import a Project";
4. Click "Import Manually";
5. Fill in the project details by:
    1. Providing your package name (e.g., `pycounts`);
    2. The GitHub repository URL (e.g., `https://github.com/TomasBeuzen/pycounts`); and,
    3. Specify the default branch as `main`.
6. Click "Next" and then "Build version".

After following the steps above, your documentation should be successfully built by [Read the Docs](https://readthedocs.org/) and you should be able to access it via the "View Docs" button on the build page. For example, the documentation for `pycounts` is now available at <https://pycounts.readthedocs.io/en/latest/>. This documentation will be automatically re-built by Read the Docs each time you push changes to your GitHub repository.

>The *`.readthedocs.yml`* file that `py-pkgs-cookiecutter` created for us in the root directory of our Python package contains the configuration settings necessary for Read the Docs to properly build our documentation. It specifies what version of Python to use and tells Read the Docs that our documentation requires the extra packages specified in *`pycounts/docs/requirements.txt`* to be generated correctly.

<!-- #endregion -->

## Tagging a package release with version control

<!-- #region -->
We have now created all the source files that make up version 0.1.0 of our `pycounts` package, including Python code, documentation, and tests - well done! In the next section we'll turn all these source files into a distribution package that can be easily shared and installed by others. But for those using version control, it's helpful at this point to tag a release of your package's source. If you're not using version control, you can skip to **{numref}`03:Building-and-distributing-your-package`**.

Tagging a release means that we permanently "tag" a specific point in our repository's history, and then create a downloadable "release" of all the files in our repository in the state they were in when the tag was made. It's common to tag a release for each new version of your package, as we'll discuss more in **Chapter 7: [Releasing and versioning]**.

Tagging a release is a two-step process involving both Git and GitHub:

1. Create a tag marking a specific point in a repository's history using the command `git tag`; and,
2. On GitHub, create a release of all the files in your repository (usually in the form of a zipped archive like *.zip* or *.tar.gz*) based on your tag. Others can then download this release if they wish to view or use your package's source files as they existed at the time the tag was created.

We'll demonstrate this process by tagging a release of v0.1.0 of our `pycounts` package. First, we need to create a tag identifying the state of our repository at v0.1.0 and then push the tag to GitHub using the following `git` commands at the command line:

```{prompt} bash \$ auto
$ git tag v0.1.0
$ git push --tags
```

Now if you go to the `pycounts` repository on GitHub and navigate to the "Releases" tab, you should see a tag like that shown in {numref}`03-tag`.

```{r 03-tag, fig.cap = "Tag of v0.1.0 of `pycounts` on GitHub.", out.width = "100%", fig.retina = 2, fig.align = "center", echo = FALSE, message = FALSE, warning = FALSE}
knitr::include_graphics("../images/03-tag.png")
```

To create a release from this tag, click "Draft a new release". You can then identify the tag from which to create the release and optionally add some additional details about the release as shown in {numref}`03-release-1`.

```{r 03-release-1, fig.cap = "Making a release of v0.1.0 of `pycounts` on GitHub.", out.width = "100%", fig.retina = 2, fig.align = "center", echo = FALSE, message = FALSE, warning = FALSE}
knitr::include_graphics("../images/03-release-1.png")
```

After clicking "Publish release", GitHub will automatically create a release from your tag, including compressed archives of your code in *.zip* and *.tar.gz* format, as shown in {numref}`03-release-2`.

```{r 03-release-2, fig.cap = "Making a release of v0.1.0 of `pycounts` on GitHub.", out.width = "100%", fig.retina = 2, fig.align = "center", echo = FALSE, message = FALSE, warning = FALSE}
knitr::include_graphics("../images/03-release-2.png")
```

We'll talk more about making new versions and releases of your package as you update it (e.g., modify code, add features, fix bugs, etc.) in **Chapter 7: [Releasing and versioning]**.
<!-- #endregion -->

## Building and distributing your package

### Building your package

Right now, our package is a collection of files and folders that is difficult to share. If someone wanted to use our package (including ourselves wanting to use our package in a different project) they would need to have a copy of all these source files to be able to install it. The solution to this problem is to create a "distribution package". A distribution package is a single archive file containing all the files and information necessary to install a package. Distribution packages are often called "distributions" for short.

The main types of distributions in Python are source distributions (known as "sdists") and wheels. sdists are a compressed archive of all the source files, metadata, and instructions needed to construct a package that can be installed by Python. When installing a package from an sdist, all this information is used to build the package on the user's computer before it is installed.

In contrast, wheels are pre-built versions of a package for specific operating systems. They are the preferred distribution format because they only need to be copied to the location on your computer where Python searches for packages, no build step is required. We'll discuss sdists and wheels in much more detail in **{numref}`04:04:Package-distribution-and-installation`**, but when sharing a package it's common to create both. We can easily create an sdist and wheel of a package with `poetry` using the command `poetry build`. Let's do that now for our `pycounts` package by running the following command from our root package directory:

```{prompt} bash \$ auto
$ poetry build
```

```console
Building pycounts (0.1.0)
  - Building sdist
  - Built pycounts-0.1.0.tar.gz
  - Building wheel
  - Built pycounts-0.1.0-py3-none-any.whl
```

After running this command, you'll notice a new directory in your package called *`dist`*:

```
pycounts
├── .readthedocs.yml
├── CHANGELOG.md
├── CONDUCT.md
├── CONTRIBUTING.md
├── dist
│   ├── pycounts-0.1.0-py3-none-any.whl  <- wheel
│   └── pycounts-0.1.0.tar.gz            <- sdist
├── docs
│   └── ...
├── LICENSE
├── poetry.lock
├── pyproject.toml
├── README.md
├── src
│   └── ...
└── tests
    └── ...
```

Those two new files are the sdist and wheel for our `pycounts` package. A user could install our package now if they had one of these distributions by using `pip install`. For example, to install the wheel (the preferred distribution type), you could enter the following in a terminal:

```{prompt} bash \$ auto
$ cd dist
$ pip install pycounts-0.1.0-py3-none-any.whl
```

```console
Processing ./pycounts-0.1.0-py3-none-any.whl
...
Successfully installed pycounts-0.1.0
```

To install using the sdist, you would have to unpack the sdist archive before running `pip install`. In the command below we use the command line tool `tar` with argument `x` (extract the input file), `z` (gunzip the input file), `f` (apply operations to the provided input file) to unpack the sdist, but the command on your specific operating system might be different.

```{prompt} bash \$ auto
$ tar xzf pycounts-0.1.0.tar.gz
$ pip install pycounts-0.1.0/
```

```console
Processing ./pycounts-0.1.0-py3-none-any.whl
  Installing build dependencies ... done
    Getting requirements to build wheel ... done
    Preparing wheel metadata ... done
...
Successfully built pycounts
Successfully installed pycounts-0.1.0
```

Note in the output above how installing from an sdist requires a build step prior to installation. For those interested, we discuss the nuances of installing from sdists vs wheels in **{numref}`04:Package-distribution-and-installation`**.

Creating a distribution for our package is most useful if we make it available from an online repository like [Python Package Index (PyPI)](https://pypi.org/), the official online software repository for Python. This would allow users to simply run `pip install pycounts` to install our package, without needing the sdist or wheel files locally, and we'll do this in the next section. But even if you don't intend to share your package, it can still be useful to build and install distributions for two reasons:
1. A distribution is a self-contained copy of your package's source files that's easy to move around and store on your computer. It makes it easy to retain distributions for different versions of your package, so that you can re-use or share them if you ever need to.
2. Recall that `poetry` installs package in "editable mode", such that a link to the package's location is installed, rather than an independent distribution of the package itself. This is useful for *development purposes*, because it means that any changes to the source code will be immediately reflected when you next `import` the package, without the need to `poetry install` again. However, for *users* of your package (including yourself using your package in other projects), it is often better to install a "non-editable" version of the package (the default behavior when you `pip install` an sdist or wheel) because a non-editable installation will remain stable and immune to any changes made to the source files on your computer.

### Publishing to TestPyPI

<!-- #region -->
At this point, we have distributions of `pycounts` which we want to share with the world by publishing to the [PyPI](https://pypi.org/). However, it is good practice to do a "dry run" and check that everything works as expected by submitting to [TestPyPi](https://test.pypi.org/) first. `poetry` has a `publish` command which we can use to do this, however the default behavior is to publish to PyPI. So we need to add TestPyPI to the list of repositories `poetry` knows about using the following command:

```{prompt} bash \$ auto
$ poetry config repositories.test-pypi https://test.pypi.org/legacy/
```

To publish to TestPyPI we can use `poetry publish` (you will be prompted for your TestPyPI username and password - sign up if you have not already done so):

```{prompt} bash \$ auto
$ poetry publish -r test-pypi
```

```console
Username: TomasBeuzen
Password: 
Publishing pycounts (0.1.0) to test-pypi
 - Uploading pycounts-0.1.0-py3-none-any.whl 100%
 - Uploading pycounts-0.1.0.tar.gz 100%
```

>Rather than entering your username and password every time you want to publish a distribution to TestPyPI or PyPI, you can configure an API token as described in the PyPI [documentation](https://pypi.org/help/#apitoken).

Now we should be able to visit our package on TestPyPI. The URL for our `pycounts` package is: <https://test.pypi.org/project/pycounts/>. We can try installing our package using `pip` from the command line with the following command:

```{prompt} bash \$ auto
$ pip install --index-url https://test.pypi.org/simple/ pycounts
```

>By default `pip install` will search PyPI for the named package. However, we want to search TestPyPI because that is where we uploaded our package. The argument `--index-url` points `pip` to the TestPyPI index.

Finally, it's important to note that not all developers upload their packages to TestPyPI; some only upload them directly to PyPI. If your package depends on packages that are not on TestPyPI you will have to tell `pip` to look for them on PyPI instead. To do that, you can use the argument `--extra-index-url` as below:

```{prompt} bash \$ auto
$ pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple pycounts
```
<!-- #endregion -->

### Publishing to PyPI

If you were able to upload your package to TestPyPI and install it without error, you're ready to publish your package to PyPI. You can publish to PyPI using the `poetry publish` command without any arguments:

```{prompt} bash \$ auto
$ poetry publish
```

Your package will then be available on PyPI (e.g., <https://pypi.org/project/pycounts/>) and can be installed by anyone using `pip`:

```{prompt} bash \$ auto
$ pip install pycounts
```

## Summary and next steps

This chapter provided a practical overview of the key steps required to generate a fully-featured Python package. In the following chapters we'll explore each of these steps in more detail and continue to add features to our `pycounts` package. In particular, a key workflow we have yet to discuss is continuous integration and continuous deployment (CI/CD) - that is, setting up automated pipelines for running tests, building documentation, and versioning, building and deploying your package. We'll discuss CI/CD in **Chapter 8: [Continuous integration and deployment]**.

Before moving onto the next chapter, let's summarize the steps we took to develop a Python package in this chapter:

1. Create package structure using a `cookiecutter` template (**{numref}`03:Creating-a-package-structure`**).
    ```{prompt} bash \$ auto
    $ cookiecutter https://github.com/py-pkgs/py-pkgs-cookiecutter.git
    ```
2. (Optional) Put your package under version control (**{numref}`03:Put-your-package-under-version-control`**).
3. (Optional) Create and activate a virtual environment using `conda` (**{numref}`03:Create-a-virtual-environment`**).
    ```{prompt} bash \$ auto
    $ conda create --name <your-env-name> python=3.9 -y
    $ conda activate <your-env-name>
    ```
4. Add Python code and add to module(s) in the *`src/`* directory (**{numref}`03:Packaging-your-code`**), adding dependencies as needed (**{numref}`03:Adding-code-with-dependencies-to-your-package`**).
    ```{prompt} bash \$ auto
    $ poetry add <dependency>
    ```
5. Install and try out your package in a Python interpreter (**{numref}`03:Installing-your-package`**).
    ```{prompt} bash \$ auto
    $ poetry install
    ```
6. (Optional) Write tests for your package in module(s) prefixed with *`test_`* in the *`tests/`* directory. Add `pytest` as a development dependency to run your tests (**{numref}`03:Running-tests`**). Optionally add `pytest-cov` as a development dependency to calculate the coverage of your tests (**{numref}`03:Test-coverage`**).
    ```{prompt} bash \$ auto
    $ poetry add --dev pytest pytest-cov
    $ pytest tests/ --cov=<pkg-name>
    ```
7. (Optional) Create documentation source files for your package (**{numref}`03:Package-documentation`**). Optionally use `sphinx` to compile and generate an HTML render of your documentation, adding the required development dependencies (**{numref}`03:Generating-documentation`**).
    ```{prompt} bash \$ auto
    $ poetry add --dev myst-nb sphinx-autoapi sphinx-rtd-theme
    $ make html -C docs
    ```
8. (Optional) Host documentation online with [Read the Docs](https://readthedocs.org/) (**{numref}`03:Hosting-documentation-online`**).
9. (Optional) Tag a release of your package using Git and GitHub, or equivalent version control tools (**{numref}`03:Tagging-a-package-release-with-version-control`**).
10. Build sdist and wheel distributions for your package (**{numref}`03:Building-your-package`**).
    ```{prompt} bash \$ auto
    $ poetry build
    ```
11. (Optional) Publish your distributions to [TestPyPi](https://test.pypi.org/) and try installing your package (**{numref}`03:Publishing-to-TestPyPI`**).
    ```{prompt} bash \$ auto
    $ poetry config repositories.test-pypi https://test.pypi.org/legacy/
    $ poetry publish -r test-pypi
    $ pip install --index-url https://test.pypi.org/simple/ <pkg-name>
    ```
12. (Optional) Publish your distributions to [PyPi](https://pypi.org/). Your package can now be installed by anyone using `pip` (**{numref}`03:Publishing-to-PyPI`**).
    ```{prompt} bash \$ auto
    $ poetry publish
    $ pip install <pkg-name>
    ```
    
The above workflow uses a particular suite of tools (e.g., `conda`, `poetry`, `sphinx`, etc.) to develop a Python package. While there are other tools that can be used to help build Python packages, the aim of this book is to give a high-level, practical, and efficient introduction to Python packaging using modern tools, and this has influenced our selection of tools in this chapter and book. However, the concepts and workflow discussed here remain relevant to the Python packaging ecosystem, regardless of the exact tools you use to develop your Python packages.
