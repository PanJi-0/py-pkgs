

# Releasing and versioning


Previous chapters have focused on how to develop a Python package from scratch; by creating the Python source code, developing a testing framework, writing documentation, and then releasing it online via PyPI (if desired). This chapter now describes the next step in the packaging workflow; updating your package!

At any given time, your package's users (including you) will use a particular version of your package in a project. If you change the package's source code, their code could potentially break (imagine you change a module name, or remove a function argument a user was using). To solve this problem, developers assign a unique version number to each unique state of their package and release each new version as an independent distribution. Most of the time, users will want to use the most up-to-date version of your package, but sometimes, they'll need to use an older version that was compatible with a project they created at the time they used a particular version. Releasing versions of your package is also the main way you can communicate to your users that your package has changed (e.g, bugs have been fixed, new features have been added,etc.). In this chapter, we'll walk through this process of creating and releasing new versions of your Python package.

## Version numbering

Versioning is the process of adding unique identifiers to different versions of your package. The unique identifier you use may be name-based or number-based, but most Python packages use [semantic versioning](https://semver.org) for identifying versions of their software. In semantic versioning, a version number consists of three integers A.B.C, where A is the "major" version, B is the "minor" version, and C is the "patch" version. In semantic versioning, the first version of a software usually starts at 0.1.0 and increments from there. We refer to an increment as a "bump" and it consists of adding 1 to either the major, minor, or patch identifier as follows:

- Patch release (0.1.0 -> 0.1.1): patch releases are typically used for bug fixes which are backward compatible. Backward compatibility refers to the compatibility of your package with previous versions of itself. So for example, if a user was using v0.1.0 of your package, they should be able to upgrade to v0.1.1 and have any code they previously wrote still work. It's completely fine to have so many patch releases that you need to use two digits (e.g., 0.1.27).
- Minor release (0.1.0 -> 0.2.0): a minor release typically includes larger bug fixes or new features which are backward compatible.
- Major release (0.1.0 -> 1.0.0): release 1.0.0 is used for the first stable public release of your package. After that, major releases are made for changes that are not backward compatible and may affect many users. Changes that are not backward compatible are called "breaking changes".

Most of the time, you'll be making patch and minor releases. But even with the guidelines above, versioning a package can be a little subjective and requires you to use your best judgment. For example, small packages might make a patch release for each individual bug fixed or a minor release for each new feature added (such as a new function). In contrast, larger packages will often group multiple bug fixes into a patch releases or multiple features into a minor release; because making a release for every single change would result in an overwhelming and confusing amount of releases! {numref}`release-table` shows some practical examples of major, minor, and patch release for the Python software itself. To help clarify when releases should be made, some developers create a "version policy" document for their package; the `pandas` [version policy](https://pandas.pydata.org/docs/development/policies.html#version-policy) is a good example of this.

```{table} Examples of major, minor, and patch releases of the Python software.
:name: release-table

|Release Type|Version Bump|Description|
|:---    |:---   | :---      |
|Major|2.X.X -> 3.0.0 ([December, 2008](https://www.python.org/downloads/release/python-300/))| This release included breaking changes, for example, `print()` became a function, and integer division resulted in creation of a float rather than an integer. Many built-in objects like dictionaries and strings also changed considerably, and many old features were removed in this release.|
|Minor|3.8.X -> 3.9.0 ([October, 2020](https://www.python.org/downloads/release/python-390/))| Many new features and optimizations were added in this release, for example, new string methods to remove prefixes (`.removeprefix()`) and suffixes (`.removesuffix()`) were added and a new parser was implemented for CPython (the engine that actually compiles and executes your Python code).|
|Patch|3.9.5 -> 3.9.6 ([June, 2021](https://www.python.org/downloads/release/python-396/))| This release contained many bug fixes and maintenance changes, for example, a confusing error message was updated in the `str.format()` method, the version of `pip` bundled with Python downloads was updated from 21.1.2 -> 21.1.3, and several parts of the documentation were updated.|
```

## Bumping package version

We'll describe the workflow for releasing a new version of your package in **{numref}`07:Checklist-for-releasing-a-new-package-version`**. The first step in that workflow is to bump your package's version and there's a few ways to do that so it's worth discussing first.

### Manual version bumping

Once you've decided what the new version of your package will be (i.e., are you making a patch, minor, or major release) you need to update the package's version number in your source code. For a `poetry`-managed project, that information is in the *`pyproject.toml`* file. Consider the *`pyproject.toml`* file of the `pycounts` package we developed in **Chapter 3: [How to package a Python]**, and the top of which looks like this:

```{code-block} toml
---
emphasize-lines: 3
---
[tool.poetry]
name = "pycounts"
version = "0.1.0"
description = "Calculate word counts in a text file!"
authors = ["Tomas Beuzen"]
license = "MIT"
readme = "README.md"

...rest of file hidden...
```

Imagine we wanted to make a patch release of our package. We could simply increment the `version` number manually in this file to "0.1.1" and many developers do take this manual approach. An alternative semi-automated approach is to use the the `poetry version` command. The `poetry version` command can be used with the arguments `patch`, `minor` or `major` depending on how you want to update the version of your package. For example, to make a patch release, we would run the following at the command line:

```{prompt} bash \$ auto
$ poetry version minor
```

```console
Bumping version from 0.1.0 to 0.1.1
```

The head of our `pyproject.toml` file now looks like this:

```toml
[tool.poetry]
name = "pycounts"
version = "0.1.1"
...
```

### Automatic version bumping

In this book, we're interested in automating as much as possible of the packaging workflow. While the manual versioning approach described above in **{numref}`07:Manual-version-bumping`** is certainly used by many developers, we can do things more efficiently! To automate version bumping, you'll need to be using a version control system like Git. If you chose not to use version control for your package, you can skip to **{numref}`07:Checklist-for-releasing-a-new-package-version`**.

[Python Semantic Release (PSR)](https://python-semantic-release.readthedocs.io/en/latest/) is a tool that can automatically bump version numbers based on keywords it finds in commit messages. The idea is to use a standardized commit message format and syntax which PSR can parse to determine how to increment the version number. The default commit message style is the [Angular commit style](https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#commit-message-format) which looks like this:

```
<type>(optional scope): succinct description of the change

(optional body: the motivation for the change and contrast this with previous behavior)

(optional footer: note BREAKING CHANGES here, as well as any issues to be closed)
```

`<type>` refers to the kind of change made and is usually one of:
- `feat`: A new feature
- `fix`: A bug fix
- `docs`: Documentation only changes
- `style`: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)
- `refactor`: A code change that neither fixes a bug nor adds a feature
- `perf`: A code change that improves performance
- `test`: Adding missing or correcting existing tests
- `chore`: Changes to the build process or auxiliary tools and libraries such as documentation generation

`scope` is an optional inclusion that provides context for where the change was made.

The important point to learn here is that different text in the commit message will trigger PSR to make different kinds of releases:
- A `<type>` of `fix` triggers a patch version bump, e.g.;
    ```{prompt} bash \$ auto
    $ git commit -m "fix(code): change confusing error message in plotting.plot_words"
    ```
- A `<type>` of `feat` triggers a minor version bump, e.g.;
    ```{prompt} bash \$ auto
    $ git commit -m "feat(code): add example data to package"
    ```
- The text `BREAKING CHANGE:` in the `footer` will trigger a major release, e.g., 
    ```{prompt} bash \$ auto
    $ git commit -m "feat(code): move code from plotting module to pycounts module
    $ 
    $ BREAKING CHANGE: plotting module no longer exist after this release."
    ```

To use PSR we need to install and configure it. To install PSR as a developmet dependency of a `poetry`-managed project, you can run:

```{prompt} bash \$ auto
$ poetry add --dev python-semantic-release
```

To configure PSR, we just need to tell it where our version number is stored. As we saw in **{numref}`07:Manual-version-bumping`**, for a `poetry`-managed project, the package version is stored in the *`pyproject.toml`* file,  as the variable `version` under the heading `[tool.poetry]` (headings are called "tables" in TOML file jargon). To tell PSR this, we need to add a new table to the *`pyproject.toml`* file called `[tool.semantic_release]` within which we specify that our `version_variable` is stored at `pyproject.toml:version`:

```toml
...rest of file hidden...

[tool.semantic_release]
version_variable = "pyproject.toml:version"
```

To use PSR to automatically bump your package's version number, you can now use the command `semantic-release version` at the command line. As a simple example, imagine we have a package at version 0.1.0, make a bug fix and commit it with the following message:

```{prompt} bash \$ auto
$ git commit -m "fix(code): change confusing error message in plotting.plot_words"
```

We can run `semantic-release version` to update our version number. In the command below, we'll specify the argument `-v DEBUG` to print information to the screen so you can get an inside look at how PSR works:

```{prompt} bash \$ auto
$ semantic-release version -v DEBUG
```

```console
Creating new version
debug: get_current_version_by_config_file()
debug: Parsing current version: path=PosixPath('pyproject.toml') pattern='version *[:=] *["\\\'](\\d+\\.\\d+(?:\\.\\d+)?)["\\\']' num_matches=1
debug: Regex matched version: 0.1.0
debug: get_current_version_by_config_file -> 0.1.0
Current version: 0.1.0
debug: evaluate_version_bump('0.1.0', None)
debug: parse_commit_message('fix(code): change confusing error message in plotting.plot_words')
debug: parse_commit_message -> ParsedCommit(bump=1, type='fix', scope='code', descriptions=['change confusing error message in plotting.plot_words'], breaking_descriptions=[])
debug: Commits found since last release: 1
debug: evaluate_version_bump -> patch
debug: get_new_version('0.1.0', 'patch')
debug: get_new_version -> 0.1.1
debug: set_new_version('0.1.1')
debug: Writing new version number: path=PosixPath('pyproject.toml') pattern='version *[:=] *["\\\'](\\d+\\.\\d+(?:\\.\\d+)?)["\\\']' num_matches=1
debug: set_new_version -> True
debug: commit_new_version('0.1.1')
debug: commit_new_version -> [main d82fa3f] 0.1.1
debug:  Author: semantic-release <semantic-release>
debug:  1 file changed, 5 insertions(+), 1 deletion(-)
debug: tag_new_version('0.1.1')
debug: tag_new_version -> 
Bumping with a patch version to 0.1.1
```

This command automatically updates the version number in the the *`pyproject.toml`* file and automatically creates a new tag for your package's source files (something we talked about in **{numref}`03:Tagging-a-package-release-with-version-control`**). In **{numref}`XXX`** we'll go through a real example of using PSR with our `pycounts` package.

## Checklist for releasing a new package version

Now that we know about versioning and how to increment the version of our package, we're ready to run through a release checklist. We'll make a real release of our `pycounts` package from v0.1.0 to v0.2.0 to demonstrate each step in the release checklist practically.

### Step 1: make changes to package source files

This is an obvious one, but before you can make a new release, you need to make the changes to your package's source that will comprise your new release!

Consider our `pycounts` package. We published the first release of our package in **Chapter 3: [How to package a Python]**. Since then, we've made a few changes. Specifically:
- In **Chapter 4: [Package structure and distribution]** we added a new "datasets" module to our package along with some example data that users could load and use to try out the functionality of our package.
- In **Chapter 5: [Testing]** we significantly upgraded our testing suite by adding several new tests to the *`tests/test_pycounts.py`* file.

The above changes would constitute a minor release (we added a new feature and made some significant changes to our package's test framework). However, we'll be using PSR. In **{numref}`XXX`** and **{numref}`XXX`** we added these changes to version control with the following commit messages:

```{prompt} bash \$ auto
$ git commit -m ""
```

The syntax we used for these messages is important because we'll be using PSR (**{numref}`07:Automatic-version-bumping`**) to parse these messages and automatically bump our package version for us.

>In practice, changes are usually made to a package's source using branches. This keeps the changes completely separate from the existing version of the code. We didn't use branches in this book because it adds another layer of complexity onto the already 


### Step 2: bump version number

<!-- #region -->
When you've made the desired changes to your package and are ready to release it, you need to bump the version manually (**{numref}`07:Manual-version-bumping`**) or automatically with the PSR tool (**{numref}`07:Automatic-version-bumping`**).

We'll use the PSR tool but if you're not using Git as a version control system, you'll need to do this step manually. To use PSR to bump our package version all we need to do is run the following command:

>If you want to see exactly what PSR found in your commit messages and why it decided to make a patch, minor, or major release, add the argument `-v debug` to the `semantic-release version` command.

```{prompt} bash \$ auto
$ semantic-release version
```

```console
Creating new version
Current version: 0.1.0
Bumping with a minor version to 0.2.0
```

This step automatically updated our package's version in the *`pyproject.toml`* file and created a new tag for our package, "v0.2.0", which you could view by typing `git tag --list` at the command line:

```{prompt} bash \$ auto
$ git tag --list
```

```console
v0.1.0
v0.2.0
```
<!-- #endregion -->

<!-- #region -->
Once the package source code has been updated and is ready to be released we need to update the package version number. For our `pycounts` package setup, all the package metadata is handled in the *`pyproject.toml`* file and this is the only place we need to update the version number (note that other package setups may include this information in different and various places). The head of our *`pyproject.toml`* file currently looks like this:

```toml
[tool.poetry]
name = "pycounts"
version = "0.1.0"
...
```

We could increment the `version` number manually to 0.2.0 or we can use the `poetry` command `version` to do it for us. In the interest of efficiency and automation, we'll take the latter approach. The `poetry version` command can be used with the arguments `patch`, `minor` or `major` depending on how you want to update the version of your package. As we're making a new minor release, we'll use the following command in our terminal:

```{prompt} bash \$ auto
$ poetry version minor
```

```console
Bumping version from 0.1.0 to 0.2.0
```

The head of our `pyproject.toml` file now looks like this:

```toml
[tool.poetry]
name = "pycounts"
version = "0.2.0"
...
```

>`poetry` also offers other version bumping argument that cater to version schemes of other syntax. Read more in the `poetry` [documentation](https://python-poetry.org/docs/cli/#version).

<!-- #endregion -->

### Step 3: run tests and build documentation

<!-- #region -->
We've now prepped our package for release, but before we move on to sharing it with others, we should first check that its tests run and documentation builds successfully. To do this with our `pycounts` package, we should first install the package (we need to re-install as we've created a new version):

>Recall that we are working in the `pycounts` virtual environment we created with `conda` in **Chapter 3: [How to package a Python]**, which you can activate by running `conda activate pycounts` in your terminal.

```{prompt} bash \$ auto
$ poetry install
```

```console
Installing the current project: pycounts (0.2.0)
```

Now we'll check that our tests are still passing and what their coverage is using `pytest` and `pytest-cov`:

```{prompt} bash \$ auto
$ pytest tests/ --cov=pycounts
```

```console
============================= test session starts ==============================
platform darwin -- Python 3.9.2, pytest-6.2.3, py-1.10.0, pluggy-0.13.1
rootdir: /Users/tomasbeuzen/GitHub/py-pkgs/pycounts
collected 3 items                                                              

tests/test_pycounts.py ...                                                [100%]

---------- coverage: platform darwin, python 3.9.6-final-0 -----------
Name                      Stmts   Miss  Cover
---------------------------------------------
src/pycounts/__init__.py       6      0   100%
src/pycounts/datasets.py       6      0   100%
src/pycounts/plotting.py       4      0   100%
src/pycounts/simulate.py       7      0   100%
---------------------------------------------
TOTAL                        23      0   100%

============================== 3 passed in 0.41s ===============================
```

>Your package might require more checks than this, for example to determine that your code conforms to a particular code style, or can be built on different operating systems and versions of Python, etc. We'll explore some of these additional checks, as well as how to automate this testing and checking procedure in **Chapter 8: [Continuous integration and deployment]**.

Finally, we should check that our documentation still builds correctly. You typically want to create the documentation from scratch, i.e., remove any existing built documentation in your package. To do this, we first need to run `make clean -C docs/` before running `make html -C docs/`, or in the spirit of efficiently we can combine these two commands together like we do below:

```{prompt} bash \$ auto
$ make clean html -C docs/
```

```console
Running Sphinx
...
build succeeded.
The HTML pages are in _build/html.
```
<!-- #endregion -->

### Step 4: document your release

With our new release ready, and the tests and documentation passing successfully, we can document the release in what's happened in your *`CHANGELOG`*. For example, here's `pycounts`'s updated *`CHANGELOG.md`* file:

We talked about changelog format in **{numref}`06:Changelog`**.

```
# Changelog

<!--next-version-placeholder-->

## v0.2.0 (24/08/2021)

### Feature

- First release of `pycounts`

### Documentation

- Add examples

## v0.1.0 (24/08/2021)

- First release of `pycounts`!
```

`>After updating the changelog, it might be a good idea to double-check We should now check that our documentation still builds correctly:
>
>{prompt} bash \$ auto
$ make clean html -C docs/
```
````

### Step 5: Tag a release with version control

For those using remote version control on GitHub (or similar), it's time to tag a release of your package's source code. If you're not using version control, you can skip to **{numref}`Step-6:-build-and-release-package-to-PyPI`**. We discussed tagging release in **{numref}`03:Tagging-a-package-release-with-version-control`**. Recall that it's a two-step process:
1. Create a tag marking a specific point in a repository's history using the command `git tag`; and,
2. On GitHub, create a release of all the files in your repository (usually in the form of a zipped archive like *.zip* or *.tar.gz*) based on your tag. Others can then download this release if they wish to view or use your package's source files as they existed at the time the tag was created.

If using PSR to bump your package version, then step 1 was done automatically for you. If you didn't use PSR, you can make a tag manually and push it to GitHub using the following commands:

```{prompt} bash \$ auto
$ git tag v0.2.0
$ git push --tags
```

Now if you go to the `pycounts` repository on GitHub and navigate to the "Releases" tab, you should see a tag like that shown in {numref}`03-tag`.

```{r 07-tag, fig.cap = "Tag of v0.1.0 of `pycounts` on GitHub.", out.width = "100%", fig.retina = 2, fig.align = "center", echo = FALSE, message = FALSE, warning = FALSE}
knitr::include_graphics("../images/03-tag.png")
```

To create a release from this tag, click "Draft a new release". You can then identify the tag from which to create the release and optionally add some additional details about the release as shown in {numref}`03-release-1`.

```{r 07-release-1, fig.cap = "Making a release of v0.1.0 of `pycounts` on GitHub.", out.width = "100%", fig.retina = 2, fig.align = "center", echo = FALSE, message = FALSE, warning = FALSE}
knitr::include_graphics("../images/03-release-1.png")
```

After clicking "Publish release", GitHub will automatically create a release from your tag, including compressed archives of your code in *.zip* and *.tar.gz* format, as shown in {numref}`03-release-2`.

```{r 07-release-2, fig.cap = "Making a release of v0.1.0 of `pycounts` on GitHub.", out.width = "100%", fig.retina = 2, fig.align = "center", echo = FALSE, message = FALSE, warning = FALSE}
knitr::include_graphics("../images/03-release-2.png")
```

We'll talk more about making new versions and releases of your package as you update it (e.g., modify code, add features, fix bugs, etc.) in **Chapter 7: [Releasing and versioning]**.

(Step-6:-build-and-release-package-to-PyPI)=
### Step 6: build and release package to PyPI

<!-- #region -->
It's now time to build the new version of our package into an sdist and wheel. We can do that with `poetry` using the following command:

```{prompt} bash \$ auto
$ poetry build
```

```console
Building pycounts (0.2.0)
  - Building sdist
  - Built pycounts-0.2.0.tar.gz
  - Building wheel
  - Built pycounts-0.2.0-py3-none-any.whl
```

If you're only interested in using your packages yourself or sharing them privately, you could just share these wheel and/or sdists using whatever medium you like. However, we're sharing our `pycounts` package on PyPI, so we should go ahead and release our new version there.

As demonstrated in **Chapter 3: [How to package a Python]**, it's good practice to release your package on [TestPyPI](https://test.pypi.org/) first to test that everything is working as expected, before releasing on PyPI. As we've seen in previous sections of this book, `poetry` has a command called `publish` which we can use to do this, however the default behaviour is to publish to PyPI. So we need to add TestPyPI to the list of repositories `poetry` knows about via:

```{prompt} bash \$ auto
$ poetry publish -r test-pypi
```

`>The above command assumes that you have added TestPyPI to the list of repositories `poetry` knows about via:
>
>{prompt} bash \$ auto
$ poetry config repositories.test-pypi https://test.pypi.org/legacy/
```
````

Now you should be able to visit your package on TestPyPI (e.g., <https://test.pypi.org/project/pycounts/>) and download it from there using `pip` via:

```{prompt} bash \$ auto
$ pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple pycounts
```

```{note language="note"}
By default `pip install` will search PyPI for the named package. However, we want to search TestPyPI because that is where we uploaded our package. The argument `--index-url` points `pip` to the TestPyPI index. However, our package `pycounts` depends on `pandas` which can't be found on TestPyPI (it is hosted on PyPI). So, we need to use the `--extra-index-url` argument to also point `pip` to PyPI so that it can pull any necessary dependencies of `pycounts` from there.
```

If you're happy with how your package is working, you can go ahead and publish to PyPI:

```{prompt} bash \$ auto
$ poetry publish
```
<!-- #endregion -->

## Automating releases

As you've seen in this chapter, there are quite a few steps to go through in order to make a new release of a package. In **Chapter 8: [Continuous integration and deployment]** we'll see how we can automate the entire release process, including running tests, building documentation, and publishing to TestPyPI and PyPI. We'll also demonstrate adding some more functionality and making another release of our package - because you can never have too many examples!

## Backward compatibility and deprecating package functionality

<!-- #region -->
As discussed earlier in the chapter, major version releases may come with backward incompatible changes (also called "breaking changes") which can affect your package's user base. The impact and importance of backward incompatibility is directly proportional to the number of people using your package. That's not to say that you should avoid backward incompatible changes - there are good reasons for making these changes, such as improving software design mistakes, improving functionality, or making code simpler and easier to use.

If you do need to make a backward incompatible change, it might be best to implement that change gradually, by providing adequate warning and advice to your package's user base through deprecation warnings.

We can add a deprecation warning to our code quite easily by using the [`warnings` module](https://docs.python.org/3/library/warnings.html) in the Python standard library. For example, imagine that we want to remove the `load_party()` function from the `datasets` module of our `pycounts` package in a later 1.0.0 major release. The simplest way to do this is by using the `warnings` module (part of the standard library) and adding a `FutureWarning` in our code, as shown in the `datasets.py` module below:

>If you've used any larger Python libraries before (such as `NumPy`, `Pandas` or `scikit-learn`) you probably have seen these warnings before! On that note, these large, established Python libraries offer great resources for learning how to properly manage your own package - don't be afraid to check out their source code and history on GitHub!

```python
import pandas as pd
from os.path import dirname, join
import warnings

def load_party():
    """Return a dataframe of 100 party guests.

    ...docstring hidden...
    """
    warnings.warn("This function will be deprecated in v1.0.0.", FutureWarning)
    
    module_path = dirname(__file__)  # directory location of datasets.py module
    data_path = join(module_path, "data", "party.csv")  # location of party.csv
    return pd.read_csv(data_path)

```

If we were to run our code now, we would see the `FutureWarning` printed to our output:

```{prompt} bash \$ auto
$ python
```

```python
>>> import pycounts
>>> df = pycounts.load_party()
```

```console
datasets.py:29: FutureWarning: This function will be deprecated in 1.0.0.
```

A few other things to think about when making backward incompatible changes:

- If you're changing a function significantly, consider keeping both the legacy (with a deprecation warning) and new version of the function for a few versions to help users make a smoother transition to using the new function.
- If you're deprecating a lot of code, consider doing it in small increments over mutliple releases.
- If your backward incompatible change is a result of one of your package's dependencies changing, it is often better to warn your users that they require a newer version of a dependency rather than immediately making it a required dependency (which might break a users' other code).
- Documentation is key! Don't be afraid to be verbose about documenting backward incompatible changes in your package documentation, remote repository, email list, etc.
<!-- #endregion -->
