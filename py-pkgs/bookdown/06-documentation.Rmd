

# Documentation


Writing documentation for your package is arguably one of the most important, but perhaps least exciting, parts of the packaging process. The purpose of documentation is to help users understand how they can use and interact with your package, without having to read the source code. For the users of your code (including your future self), having readable and accessible documentation is invaluable. The reality is, if no one knows how to use your package, it will probably not get used!

In **{numref}`03:Package-documentation`** we walked through the steps required to create documentation, compile it into a user-friendly and shareable HTML format, and then host it online. We'll revise those steps here and will provide more detail about documentation workflow and the individual elements of package documentation and when and why they should be included.

## Documentation content and workflow

A typical Python package will include the documentation shown in {numref}`documentation-table`:

```{table} Typical Python package documentation.
:name: documentation-table

|Documentation|Description|
|:---    | :---      |
|README|Provides high-level information about the package, e.g., what it does, how to install it, and how to use it|
|License|Explains who owns the copyright to your package source and how it can be used and shared.|
|Contributing guidelines|Explains how to contribute to the project.|
|Code of conduct|Defines standards for how to appropriately engage with and contribute to the project.|
|Changelog|A chronologically ordered list of notable changes to the package over time, usually organized by version.|
|Examples|Step-by-step, tutorial-like, examples showing how the package works in more detail.|
|Docstrings| Text appearing as the first statement in a function, method, class or module in Python that describes what the code does an dhow to use it. Accessible to users via the `help()` command.|
|API reference|An organized list of the user-facing functionality of your package (i.e., functions, classes, etc.) along with a short description of what they do and how to use them. Typically created automatically from your package's docstrings and `sphinx`|
```

---

but clearly the amount of documentation needed to support your package varies depending on its purpose and the intended audience. For example, if you're developing a package to share code among your own personal projects, or as a way to bundle up a reproducible data analysis, then you may not need contributing guidelines or examples.

- while you might not need this documentation for every package, the reality is that sometimes packages originally intended for personal use, do end up being share, so we recommend generally including eveyrhting. 

Packages that start out for personal use, and that end up being useful, often end up being shared. I think we should suggest they do all this for any package, and use that rationale as to why (and that, it's much harder to find the time and motivation to write those docs after you are done with the package and are at the sharing stage...)

Documentatino is not usually included in a package distribution (i.e., the thing that users will isntall). Instead, it's usually shared

While you may feel that not all of this documentatio nis needed, often a project that is originally created for personal use might end up being shared, so there' sno harm

---

We'll discuss what each of these pieces of documentation are, how to write them, and where to put them in **{numref}`06:Writing-documentation`**. But it's first helpful to understand the big-picture documentation workflow and what we're aiming to build.

The typical workflow for documenting a Python package consists of three steps:
1. **Write documentation**: manually write the documentation source files in  {numref}`documentation-table`, usually in plain-text format, that will support your package;
2. **Build documentation**: compile manually written documentation into an organized, coherent, and shareable format such as HTML or PDF using a documentation generator tool like `sphinx`. {numref}`06-documentation-1` shows an example of built documentation;

    ```{figure} images/03-documentation-1.png
    ---
    width: 100%
    name: 06-documentation-1
    alt: The documentation homepage generated by `sphinx`.
    ---
    The documentation homepage generated by `sphinx`.
    ```

3. **Host documentation online**: share documentation online so it can be easily accessed by anyone with an internet connection, using a free service like [Read the Docs](https://readthedocs.org) or [GitHub Pages](https://pages.github.com). For example, the documentation we built for `pycounts` in **{numref}`03:Package-documentation`** is available online at <https://pycounts.readthedocs.io/en/latest/>.

In the remaining sections of this chapter, we'll walk through each of the above steps.

## Writing documentation

<!-- #region -->
{numref}`documentation-table` shows the typical documentation included in a package. But where does all this documentation go?
- The README, License, Code of conduct, Contributing guidelines, and Changelog files usually appear in the root package directory. They contain important information about your project which should not be buried in its directory structure.
- Additional documentation such as usage examples are usually included in a *`docs/`* subdirectory. This directory also houses the source and configuration files required to build documentation with `sphinx` (such as that shown in {numref}`06-documentation-1`), as we'll talk about in **{numref}`x`**
- Docstrings are written in the Python modules of your package (i.e., *.py* files in the *`src/`* directory). They precede code defintions, as we'll tlak about in **{numref}`x`**.

There's a lot to think about here, but the reality is that most developers make Python packages from templates that create this documentation automatically. For example, consider the `pycounts` package we created using  the `cookiecutter` templating package and the `py-pkgs-cookiecutter` template in **{numref}`03:Creating-a-package-structure`**:

```{code-block}
---
emphasize-lines: 3-9
---
pycounts
├── .readthedocs.yml
├── CHANGELOG.md
├── CONDUCT.md
├── CONTRIBUTING.md
├── docs
│   └── ...
├── LICENSE
├── README.md
├── pyproject.toml
├── src
│   └── ...
└── tests
    └── ...
```

```{note language="note"}
We hide the contents of the docs file here because it might be confusing to look at before we get to **{numref}`sphinx`**.
```

As you can see from the structure above, documentation is typically written in a plain-text markup format such as [Markdown](https://en.wikipedia.org/wiki/Markdown) (*.md*). [reStructuredText](https://www.sphinx-doc.org/en/master/usage/restructuredtext/index.html) (*.rst*) is also commonly used to write documentation, but we prefer Markdown in this book because it is widely used, and we feel it has a less verbose and more intuitive syntax than reStructuredText. Markdown is also supported on a wide variety of IDEs and websites. (check out the [Markdown Guide](https://www.markdownguide.org) to learn more about Markdown syntax). We'll show examples of Markdown syntax and writing these documents in the following sections.
<!-- #endregion -->

### README

The README file is the "map" of your package. It's typically the first thing users will see and read when interacting with your package and should provide high-level information such as: what your package does, how it can be installed, a brief demonstration of usage, who created the package, how it is licensed, and how to contribute it. The README is the "gateway" to your package, without it, users won't know where to begin.

As an example of a README file, we show `pycounts` README below:

````
# pycounts

Calculate word counts in a text file!

## Installation

```bash
$ pip install pycounts
```

## Usage

`pycounts` can be used to count words in a text file and plot the results as follows:

```python
from pycounts.pycounts import count_words
from pycounts.plotting import plot_words
import matplotlib.pyplot as plt

file_path = "test.txt"  # path to your file
counts = count_words(file_path)
fig = plot_words(counts, n=10)
plt.show()
```

## Contributing

Interested in contributing? Check out the contributing guidelines. Please note that this project is released with a code of conduct. By contributing to this project, you agree to abide by its terms.

## License

`pycounts` was created by Tomas Beuzen and licensed under the terms of the MIT license.

## Credits

`pycounts` was created with [`cookiecutter`](https://cookiecutter.readthedocs.io/en/latest/) and the `py-pkgs-cookiecutter` [template](https://github.com/py-pkgs/py-pkgs-cookiecutter).
````

>In the Markdown text above, the following syntax is used:
- Headers are denoted with number signs (\#). The number of number signs corresponds to the heading level.
- Code blocks are bounded by three back-ticks (\`\`\`). A programming language can succeed the opening bounds to specify how the code syntax should be highlighted.
- Links are defined using brackets \[\] to enclose the link text, followed by the URL in parentheses ().

While the raw text above doesn't look like much, the Markdown syntax formats the text nicely when rendered using a tool like `sphinx` (as shown in {numref}`06-documentation-1`), or in any IDE or service that supports Markdown rendering (which is most of them). This is why we use Markdown to write package documentation - it can be written in plain-text but renders into something so much more!

### License

A license tells others what they can and can't do with your code. The [Open Source Initiative (OSI)](https://opensource.org/) is a good place to learn more about different licenses and GitHub also has a [useful tool](https://choosealicense.com/) for helping choose the most appropriate license for your package. Some common licenses used for Python packages include:
- Creative Commons CC0 1.0 Universal (CC0 1.0): releases your software into the public domain, granting permission to use it for any purpose. 
- MIT license: allows users to do whatever they want with your software, as long as they include the original copyright and license notice in any copy or substantial modification of it. 
- GNU General Public License v3 (GPL-3): less permissive than the above licenses. Any changes made to your software must be recorded, and the complete source code of the original software and modifications of it must be made available under the same GPL-3 license.

If you don't include a license, then default copyright laws apply which typically means that you retain all rights to your source code and no one may download, reproduce, distribute, or create derivative works from your package. This might be fine if you want to keep your work private or proprietary, but if you open-source your work without a license, others will be unable to use or contribute to it.

### Contributing guidelines

A contributing guidelines file (often named "CONTRIBUTING") outlines procedures for how users can efficiently and helpfully contribute to your project. These guidelines will vary depending on how you're sharing your package's source with others, but they typically include information on what kind of contributions you're accepting, and how to make those contributions (usually via the use of a version control system). GitHub provides a good [guide](https://help.github.com/en/github/building-a-strong-community/setting-guidelines-for-repository-contributors) for adding a contributing file to your project.

Having clear contributing guidelines streamlines the handling and incorporation of contributions into your package. Without contributing guidelines, it's not clear how others should effectively contribute, or if you would like contributions at all. As a result, you may receive contributions you don't want, or in a way you don't want, which could waste yours and other people's time.

### Code of conduct

A code of conduct file (often named "CONDUCT") is used to define community standards, identify a welcoming and inclusive project, and outline procedures for handling abuse. GitHub provides an excellent [guide](https://help.github.com/en/github/building-a-strong-community/adding-a-code-of-conduct-to-your-project) for adding a code of conduct to your project. A code of conduct helps the community feel safe, respected, and welcome to contribute to your package. Without it, others may not want to contribute to your package and conflicts may arise among contributors with conflicting ideas.

### Changelog

<!-- #region -->
A changelog is a file which contains a chronologically ordered list of changes made to your package. Changes are typically organized per released version of your package, something we'll discuss more in **Chapter 7: [Releasing and versioning]**. Having a changelog helps users and contributors understand the history of a package and how it has evolved over time. Without it, there's no easy way for users to understand when, what, and why changes were made to your package.

Changelog's are made for humans to read. They typically contain dot-points of important changes made for each version of your package, grouped into categories such as: "Feature", "Fix", "Documentation", "Tests", and with the latest version at the top of the file. An example of a hypothetical changelog for our `pycounts` package is shown below and the rendered version is shown in Fig X:

```
# Changelog

<!--next-version-placeholder-->

## v0.2.1 (24/08/2021)

### Fix

- First release of `pycounts`

## v0.2.0 (24/08/2021)

### Feature

- First release of `pycounts`

### Documentation

- Add examples

## v0.1.0 (24/08/2021)

- First release of `pycounts`
```

>In **Chapter 8: [Continuous integration and deployment]**, we'll show how you can automatically update your changelog with continuous integration.

<!-- #endregion -->

### Examples

<!-- #region -->
Creating examples of how to use your package can be invaluable to new and existing users alike. Unlike the brief "Usage" heading in the README in **{numref}`06:README`**, these examples are more like tutorials, including a mix of text, figures, and code that demonstrates the functionality and common workflows of your package step-by-step. The examples should be realistic and illustrate workflows that users of your package might actually do (as opposed to toy examples).

It's important to think about your audience here too. Sometimes, it's necessary to create examples for different levels of expertise. Examples for new users will introduce the basic functionality of your package step-by-step, with plenty of commentary about what each piece of code is doing and why. Examples for more competent users might be more code-based, requiring less explanation of each step, and will likely explore more advanced usage of the package.

You could certainly write examples from scratch using a plain-text format like Markdown but this can be inefficient and prone to errors. Instead, we recommend creating examples using a computational notebook like a Jupyter notebook (*.ipynb* file). Jupyter notebooks are interactive documents that can contain code, equations, text, and visualizations. They are effective for demonstrating examples because they directly import and use code from your package; this ensures you don't make mistakes when writing out your example, and allows users to download, execute, and interact with the notebooks themselves (as opposed to just reading text). 

To create examples in a Jupyter notebook, you'll need to install the Jupyter software. If you're using a `poetry`-managed project, as we do in this book, you can install the Jupyter software as a development dependency of your package with the following command:

```{prompt} bash \$ auto
$ poetry add --dev jupyter
```

Once installed, you can launch the Jupyter Notebook application with the following command:

```{prompt} bash \$ auto
$ jupyter notebook
```

>If you're developing your Python packages in an IDE that supports notebooks, such as VS Code or JupyterLab, feel free to create your notebooks there.

Notebooks are made of "cells" that can contain Python code or Markdown text. Discussing how to use the Jupyter application is beyond the scope of this book, and we refer readers to the Jupyter [documentation](https://jupyter-notebook.readthedocs.io/en/latest/?badge=latest) to learn more. However, **{numref}`06-jupyter-example-2`**, shows an example notebook that we created to support our `pycounts` package in **{numref}`03:Creating-usage-examples`**.

```{r 06-jupyter-example-2, fig.cap = "A simple Jupyter notebook using code from `pycounts`.", out.width = "100%", fig.retina = 2, fig.align = "center", echo = FALSE, message = FALSE, warning = FALSE}
knitr::include_graphics("../images/03-jupyter-example-2.png")
```

It's important to stress that because examples written in Jupyter notebooks use your package's code directly, they will immediately reflect any changes you make to your code. As opposed ot if you wrote example manually, you'd have to go back and change all the outputs. interactive notebooks uses code from  important to note is that the outputs are generated using the actual code from our package itself, they have not been included manually. 

In **{numref}`XXX`** we'll show how we can even use `sphinx` to automatically execute notebooks and include their content (including the outputs of code cells) into our built documentation collection of all our packages documentation that users can easily read and navigate through without having to start the Jupyter application!
<!-- #endregion -->

### Docstrings

A docstring is a string, surrounded by triple-quotes, at the start of a module, class, or function in Python (preceding any code) that provides documentation on what the object does and how to use it. Docstrings automatically become the object's documentation, accessible to users via the `help()` function. Docstrings are a user's first port-of-call when they are trying to use your package, they really are a necessity when creating packages, even for yourself.

General docstring convention in Python is described in [Python Enhancement Proposal (PEP) 257 - Docstring Conventions](https://www.python.org/dev/peps/pep-0257/), but there is flexibility in how you write your docstrings. A minimal docstring contains a single line describing what the object does, and that might be sufficient for a simple function or for when your code is in the early stages of development. However, for code you intend to share with others (including your future self) a more comprehensive docstring should be written. A typical docstring will include:

1. A one-line summary that does not use variable names or the function name;
2. An extended description;
3. Parameter types and descriptions;
4. Returned value types and descriptions;
5. Example usage; and,
6. Potentially more.

There are different "docstring styles" used in Python to organize this information, such as [numpydoc style](https://numpydoc.readthedocs.io/en/latest/format.html#docstring-standard), [Google style](https://github.com/google/styleguide/blob/gh-pages/pyguide.md#38-comments-and-docstrings), and [sphinx style](https://sphinx-rtd-tutorial.readthedocs.io/en/latest/docstrings.html#the-sphinx-docstring-format). In this book, we've been using the numpydoc style because we find it has an intuitive syntax and is human-readable. In the numpydoc style:
- Section headers are denoted as text underlined with dashes;
- Input arguments are denoted as:
    ```
    name : type
        Description of parameter `name`.
    ```
- Output values use the same syntax above, but specifying the `name` is optional.

As an example of a docstring, consider the `count_words()` function of our `pycounts` (numbers in the docstring below identify items in the numbered list above, but they should not be included in your docstring) In this style, header sections are denoted by text underline with dashes, and input/output arguments 

```python
def count_words(input_file):
    """Count words in a text file. (1)

    Words are made lowercase and punctuation is removed 
    before counting. (2)

    Parameters (3)
    ----------
    input_file : str
        Path to text file.

    Returns (4)
    -------
    collections.Counter
        dict-like object where keys are words and values are their counts.

    Examples (5)
    --------
    >>> count_words("text.txt")
    """
    text = load_text(input_file)
    text = clean_text(text)
    words = text.split()
    return Counter(words)
```

You can add information to your docstrings at your discretion - you won't always need all the sections above, and in some case you may want to include additional sections from the [numpydoc style documentation](https://numpydoc.readthedocs.io/en/latest/format.html#docstring-standard).

### Application Programming Interface (API) reference

An Application Programming Interface (API) reference sheet is an organized index of your package's user-facing functionality and associated docstrings. It helps users efficiently understand and search through your package's functionality without having to dig-in to the source code or run the Python `help()` command on every object they need to know about.

As a conrete example of what we're talking about, **{numref}`03-documentation-4`** show an API reference for our `pycounts` package and **{numref}`03-documentation-3`** shows the contents of clicking on the `pycounts.plotting` module.

```{r 06-documentation-4, fig.cap = "Documentation for the pycounts plotting module.", out.width = "100%", fig.retina = 2, fig.align = "center", echo = FALSE, message = FALSE, warning = FALSE}
knitr::include_graphics("../images/03-documentation-4.png")
```

```{r 06-documentation-3, fig.cap = "Documentation for the pycounts plotting module.", out.width = "100%", fig.retina = 2, fig.align = "center", echo = FALSE, message = FALSE, warning = FALSE}
knitr::include_graphics("../images/03-documentation-3.png")
```

You could create an API reference by manually copying and pasting the names of all of your package's Python objects (functions, modules, classes, etc.) and their docstrings into a plain-text file, but that would be incredibly tedious and not reproducible. Instead, API references are usually generated automatically using `sphinx` which can parse your source code to extract Python objects and their docstrings and render them into an API reference. We'll demonstrate how to do this in **{numref}`06:Building-documentation`**.

### Other package documentation

In this section we've only explored the core documentation typically included in a Python package. But you can add as much documentation as you wish! For example, you might wish to write documents for frequently asked questions (FAQ), a document referencing how your project compares to similar projects, information on project funding and attribution, etc. In general, the more documentation the better!

## Building documentation

<!-- #region -->
At the moment, the documentation we've written is spread throughout our package's directory structure in the form of plain-text Markdown files, Jupyter notebooks, and docstrings in our Python modules. Rather than requiring users to search through this directory structure to find documentation, it's common to use a documentation generator like `sphinx` to compile all of this documentation into a user-friendly output format such as HTML or PDF that is easy to view, navigate, and share with others. We showed an example of `sphinx`-generated documentation in {numref}`06-documentation-1`. As we'll see in this section, `sphinx` also has a rich ecosystem of extensions that can be used to help customize and automatically generate content to complement your manually-written documentation.

We'll demonstrate the process of building documentation with `sphinx` using our `pycounts` package. This section will effectively walk through the same steps we went through in **{numref}`03:Generating-documentation`**, so for readers that have recently read that section, feel free to skip to **{numref}`06:Hosting-documentation-online`**. 

The source and configuration files to build documentation using `sphinx` live in a *`docs/`* folder in the root of your package. The `py-pkgs-cookiecutter` automatically created this folder for us:

```{code-block}
---
emphasize-lines: 6-15
---
pycounts
├── .readthedocs.yml
├── CHANGELOG.md
├── CONDUCT.md
├── CONTRIBUTING.md
├── docs
│   ├── changelog.md
│   ├── conduct.md
│   ├── conf.py
│   ├── contributing.md
│   ├── example.ipynb
│   ├── index.md
│   ├── make.bat
│   ├── Makefile
│   └── requirements.txt
├── LICENSE
├── pyproject.toml
├── README.md
├── src
│   └── ...
└── tests
    └── ...
```

>If you don't use a template to create your Python package directory structure, the `sphinx` command `sphinx-quickstart` can be used to quickly create the source files for you.

The *`docs`* directory includes:

- *`Makefile`*/*`make.bat`*: files that contain commands needed to build our documentation with `sphinx` and do not need to be modified. [Make](https://www.gnu.org/software/make/) is a tool used to run commands to efficiently read, process, and write files. A Makefile defines the tasks for Make to execute. If you're interested in learning more about `make`, we recommend the excellent tutorial [Learn Makefiles](https://makefiletutorial.com). But for building documentation with `sphinx`, all you need to know is that having these Makefiles allows us to build documentation with the simple command `make html` and clean documentation (i.e., remove it so we can make a fresh copy) with the command `make clean`.
- *`requirements.txt`*: contains a list of documentation-specific dependencies required to host our docs on [Read the Docs](https://readthedocs.org/), which we'll discuss in **{numref}`06:Hosting-documentation-online`**;
- *`conf.py`* is a configuration script controlling how `sphinx` builds your documentation. You can read more about *`conf.py`* in the `sphinx` [documentation](https://www.sphinx-doc.org/en/master/usage/configuration.html) and we'll touch on it again shortly, but for now, it has been pre-populated by the `py-pkgs-cookiecutter` template and does not need to be modified;
- The remaining files in the `docs` directory form the content of our generated documentation, as we'll discuss in the remainder of this section.

The *`index.md`* file forms the landing page of `sphinx` documentation. Think of it as the homepage of a website. Our landing page will look like {numref}`06-documentation-2` once we build it.

```{r 06-documentation-2, fig.cap = "The documentation homepage generated by `sphinx`.", out.width = "100%", fig.retina = 2, fig.align = "center", echo = FALSE, message = FALSE, warning = FALSE}
knitr::include_graphics("../images/03-documentation-1.png")
```

For your documentation landing page, you'd typically want some high-level information about your package, and then links to the rest of the documentation you want to expose to a user. If you open *`index.md`* in an editor of your choice, that's exactly the content we are including, with a very particular kind of syntax:

````
```{include} ../README.md
```

```{toctree}
:maxdepth: 1
:hidden:

example.ipynb
changelog.md
contributing.md
conduct.md
autoapi/index
```
````

Sphinx natively supports [reStructuredText](https://www.sphinx-doc.org/en/master/usage/restructuredtext/index.html), but many developers prefer to work in Markdown (as we do in this book). The syntax shown above in *`index.md`* is a flavor of Markdown known as [Markedly Structured Text (MyST)](https://myst-parser.readthedocs.io/en/latest/syntax/syntax.html). MyST is based on Markdown but with additional syntax options compatible for use with `sphinx`. For example, the `{include}` syntax specifies that we want the *`index.md`* landing page to include the content of the *`README.md`* in our package's root directory (think of it as a copy-paste operation).

The `{toctree}` syntax defines what documents will be listed in the table of contents (ToC) on the left-hand side of {numref}`06-documentation-2`. The argument `:maxdepth: 1` indicates how many heading levels the ToC should include, and `:hidden:` specifies that the ToC should only appear in the side bar and not in the index page itself. The ToC then lists the documents we want to include and link to in our documentation.

"example.ipynb" is the notebook we wrote in section **{numref}`03:Creating-usage-examples`**. `sphinx` doesn't support relative links in a ToC, so to include the documents *`CHANGELOG.md`*, *`CONTRIBUTING.md`*, *`CONDUCT.md`* in our root, we create "stub files" *`changelog.md`*, *`contributing.md`*, and *`conduct.md`* which contain links to these documents with the `{include}` syntax from earlier (which does support relative links). For example, *`changelog.md`* contains the following text:

````md
```{include} ../CHANGELOG.md
```
````

The final document in the ToC, "autoapi/index" is an API reference sheet that will be generated automatically for us, using our package structure and docstrings, when we build our documentation.

Before we can go ahead and build our documentation, it relies on a few extensions that need to be installed and configured:

- [myst-nb](https://myst-nb.readthedocs.io/en/latest/): extension that will enable `sphinx` to parse our Markdown, MyST, and notebook files (`sphinx` only supports reStructuredTex, *.rst* files, by default);
- [sphinx-rtd-theme](https://sphinx-rtd-theme.readthedocs.io/en/stable/): a custom theme for styling the way our documentation will look;
- [sphinx-autoapi](https://sphinx-autoapi.readthedocs.io/en/latest/): extension that will parse our source code to create an API reference sheet;
- [sphinx.ext.napoleon](https://sphinxcontrib-napoleon.readthedocs.io/en/latest/): extension that enables `sphinx` to parse both numpydoc-style docstrings; and,
- [sphinx.ext.viewcode](https://www.sphinx-doc.org/en/master/usage/extensions/viewcode.html): extension that adds a helpful link to the source code of each object in the API reference sheet.

All these extensions are not necessary to create documentation with `sphinx`, but they are all commonly used in Python packaging documentation and significantly improve the look and user-experience of the generated documentation. Extensions without the `sphinx.ext` prefix need to be installed. We can install them as development dependencies in a `poetry`-managed project with the following command:

```{prompt} bash \$ auto
$ poetry add --dev myst-nb sphinx-autoapi sphinx-rtd-theme
```

Once installed, any extensions you want to use need to be added to a list called `extensions` in the *`conf.py`* configuration file. Configuration options for each extension (if they exist) can be viewed in their respective documentation, but the `py-pkgs-cookeicutter` has already taken care of everything for us, by defining the following variables within *`conf.py`*:

```python
extensions = [
    "myst_nb",
    "autoapi.extension",
    "sphinx.ext.napoleon",
    "sphinx.ext.viewcode",
    "sphinx_copybutton",
]
autoapi_dirs = ["../src"]
html_theme = "sphinx_rtd_theme"
```

With our documentation structure set up, and our extensions configured, we can now build our documentation with `sphinx` using the following command from our root package directory:

```{prompt} bash \$ auto
$ make html -C docs
```

```console
Running Sphinx
making output directory... done
...
build succeeded.
The HTML pages are in _build/html.
```

If we now look inside our *`docs`* directory we see a new directory *`_build/html`* which contains our rendered HTML files. If you open *`_build/html/index.html`* you should see the page shown in {numref}`06-documentation-2`.

The `sphinx-autoapi` extension extracted the docstrings within each module and rendered them into our documentation. You can find the generated API reference sheet by clicking "API Reference" in the table of contents. For example, {numref}`03-documentation-2` shows the functions and docstrings in the `pycounts.plotting` module. The `sphinx.ext.napoleon` enabled `sphinx` to parse our [numpydoc style](https://numpydoc.readthedocs.io/en/latest/format.html#docstring-standard) docstrings and the `sphinx.ext.viewcode` extension added the "\[source\]" link next to each function in our API reference sheet which links readers directly to the source code of the function (if they want to view it).

```{r 06-documentation-2, fig.cap = "Documentation for the pycounts plotting module.", out.width = "100%", fig.retina = 2, fig.align = "center", echo = FALSE, message = FALSE, warning = FALSE}
knitr::include_graphics("../images/03-documentation-2.png")
```

Finally, if we navigate to the "Example usage" page, {numref}`03-documentation-3` shows the Jupyter notebook we wrote in **{numref}`03:Creating-usage-examples`** rendered into our documentation, including the Markdown text, code input, and executed output. This was made possible using the `myst-nb` extension.

```{r 06-documentation-3, fig.cap = "Jupyter notebook example rendered into `pycounts`'s documentation.", out.width = "100%", fig.retina = 2, fig.align = "center", echo = FALSE, message = FALSE, warning = FALSE}
knitr::include_graphics("../images/03-documentation-3.png")
```

Ultimately, you can easily and efficiently make beautiful and many-featured documentation with `sphinx` and its ecosystem of extensions. You can now use this documentation yourself or potentially share it with others, but it really shines when you host it on the web using a free service like [Read the Docs](https://readthedocs.org/), as we'll do in the next section. 
<!-- #endregion -->

## Hosting documentation online

<!-- #region -->
If you intend to share your package with others, it will be useful to make your documentation accessible online. It's common to host Python package documentation on the free online hosting service [Read the Docs](https://readthedocs.org/), which can automate the building, deployment, and hosting of your documentation directly from an online repository. 

Read the Docs works by connecting to an online repository hosting your package documentation, such as a GitHub repository. When you push changes to your repository, Read the Docs automatically builds a fresh copy of your documentation (i.e., runs `make html`) and hosts it at the URL <https://pkgname.readthedocs.io/> (you can also configure Read the Docs to use a custom domain name). This means that any changes you make to your documentation source files are immediately deployed to your users. If you need your documentation to be private (i.e., only available to employees of a company), Read the Docs offers a paid "Business plan" with this functionality.

>[GitHub Pages](https://pages.github.com) is another popular service used for hosting documentation from a repository. However, it doesn't natively support automatic building of your documentation when you push changes to the source files. This functionality can be configured through the use of [GitHub Actions](https://github.com/features/actions), but we prefer to use Read the Docs here because of it's simpler set up.

The [Read the Docs](https://readthedocs.org) documentation will provide the most up-to-date steps required to host your documentation online. For our `pycounts` package, this involved the following steps:

1. Visit <https://readthedocs.org/> and click on "Sign up";
2. Select "Sign up with GitHub";
3. Click "Import a Project";
4. Click "Import Manually";
5. Fill in the project details by:
    1. Providing your package name (e.g., `pycounts`);
    2. The GitHub repository URL (e.g., `https://github.com/TomasBeuzen/pycounts`); and,
    3. Specify the default branch as `main`.
6. Click "Next" and then "Build version".

After following the steps above, your documentation should be successfully built by [Read the Docs](https://readthedocs.org/) and you should be able to access it via the "View Docs" button on the build page. For example, the documentation for `pycounts` is now available at <https://pycounts.readthedocs.io/en/latest/>. This documentation will be automatically re-built by Read the Docs each time you push changes to the specified default branch of your GitHub repository.

>The *`.readthedocs.yml`* file that `py-pkgs-cookiecutter` created for us in the root directory of our Python package contains the configuration settings necessary for Read the Docs to properly build our documentation. It specifies what version of Python to use and tells Read the Docs that our documentation requires the extra packages specified in *`pycounts/docs/requirements.txt`* to be generated correctly.

<!-- #endregion -->
